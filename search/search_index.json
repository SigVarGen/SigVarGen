{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SigVarGen Documentation","text":"<p>Welcome to the documentation site for SigVarGen, a Python-based framework designed for generating and augmenting synthetic signals with realistic variations, interruptions, and noise profiles.</p> <p>This framework designed to create multiple variants of a base 1D signal under the same environmental conditions. It allows the simulation of both idle-state signals and signals affected by external perturbations, enabling robust testing of algorithms in dynamic environments based on multiple measurements of the same event. Framework is suitable for time-series analysis, signal processing, and synthetic data generation in various domains such as sensor data modeling, embedded systems testing, and machine learning augmentation.</p>"},{"location":"#documentation-overview","title":"Documentation Overview:","text":"<ul> <li>Getting Started</li> <li>Installation and Dependencies</li> <li>Modules Overview</li> <li>Contributing Guidelines</li> </ul>"},{"location":"#project-links","title":"Project Links:","text":"<ul> <li>GitHub Repository</li> <li>Issues</li> <li>License</li> <li>Tutorials</li> </ul>"},{"location":"config/","title":"Config Module","text":""},{"location":"config/#config","title":"<code>config</code>","text":"<p>Location: <code>config.py</code></p>"},{"location":"config/#description","title":"Description","text":"<p>The <code>config.py</code> file provides predefined parameter configurations for signal variations, noise modulation, and device-specific frequency ranges. It defines parameter sweeps, noise functions, and device constraints, enabling realistic signal augmentation and synthetic dataset generation.</p> <p>This configuration allows for: - Device-Specific Signal Ranges: Defines the frequency and amplitude constraints for various embedded devices, sensors, and communication systems. - Parameter Sweeps: Provides preset variation ranges for different transformation operations like time shifts, gain variations, amplitude modulation, and baseline drift. - Noise Functions: Specifies different types of envelopes for modulating noise over time. - Noise Power and Modulation Factor Levels: Predefined scaling factors for controlling noise intensity and variability across experiments.</p>"},{"location":"config/#embedded-device-frequency-and-amplitude-ranges","title":"Embedded Device Frequency and Amplitude Ranges","text":"<p>The <code>EMBEDDED_DEVICE_RANGES</code> dictionary contains predefined amplitude and frequency constraints for different embedded systems. These constraints ensure that generated signals remain realistic within the operational bounds of the target device.</p>"},{"location":"config/#examples","title":"Examples:","text":"Device Amplitude (V) Frequency (Hz) Arduino Board (0, 5) (0, 12e3) Drones (0, 1) Control: (2.398e9, 2.402e9) Cameras (0, 1) (24, 120) (Frames per second) Smartphones (0, 1) LTE: (699e6, 701e6), 5G: (38.9e9, 39.1e9) Wi-Fi Routers (0, 1) WiFi 2.4 GHz: (2.395e9, 2.405e9) Smart Watches (0, 0.9e-3) (2.398e9, 2.402e9) <p>These ranges ensure that generated signals for augmentation or simulation remain within the physical constraints of real-world embedded systems.</p>"},{"location":"config/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>The <code>param_sweeps</code> dictionary defines predefined transformation parameters for different device types. These parameters control variations in time shift, warping, gain, and baseline drift, allowing for customized augmentation of signals.</p>"},{"location":"config/#example-cameras","title":"Example: Cameras","text":"Transformation Range <code>time_shift</code> [1, 51, 101, 151, 201, 251, 301] <code>time_warp</code> [0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07] <code>gain_variation</code> [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8] <code>baseline_drift_region</code> [0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4]"},{"location":"config/#example-arduino-board","title":"Example: Arduino Board","text":"Transformation Range <code>time_shift</code> [1, 51, 101, 151, 201, 251, 301] <code>time_warp</code> [0, 0.06, 0.12, 0.18] <code>gain_variation</code> [0, 0.1, 0.2, 0.3, 0.4] <code>baseline_drift</code> [0, 0.3, 0.6, 0.9, 1.2, 1.5, 1.8, 2.1, 2.4, 2.7, 3.0] <p>These parameter sweeps allow systematic variations in signal transformations, ensuring realistic data augmentation for different device categories.</p>"},{"location":"config/#noise-functions","title":"Noise Functions","text":"<p>The <code>noise_funcs</code> list defines envelope-based noise modulation functions, controlling how noise evolves over time.</p>"},{"location":"config/#available-noise-envelopes","title":"Available Noise Envelopes:","text":"Function Description None No modulation (stationary noise). envelope_linear Gradual increase/decrease in noise intensity. envelope_sine Cyclic noise modulation with sinusoidal fluctuations. envelope_random_walk Stochastic amplitude variations (random walk process). envelope_blockwise Step-like changes in noise amplitude (intermittent bursts). <p>These modulation functions allow for non-stationary noise effects, making simulations more realistic for machine learning and signal processing applications.</p>"},{"location":"config/#noise-power-and-modulation-factor-levels","title":"Noise Power and Modulation Factor Levels","text":""},{"location":"config/#npw_levels-noise-power-scaling","title":"<code>npw_levels</code>: Noise Power Scaling","text":"<p>Defines noise power variation ranges, allowing for controlled randomness in noise intensity through different measurements.</p> Level Range 1 [1, 1] (No variation) 2 [0.9, 1.1] 3 [0.85, 1.2] 4 [0.8, 1.3] 5 [0.75, 1.4] 6 [0.7, 1.5] 7 [0.65, 1.6] 8 [0.6, 1.7]"},{"location":"config/#mf_levels-modulation-factor-scaling","title":"<code>mf_levels</code>: Modulation Factor Scaling","text":"<p>Controls random fluctuations in signal amplitude, adding variability to synthetic signals through different measurements.</p> Level Range 1 [0.75, 0.85] 2 [0.8, 0.9] 3 [1, 1] (No variation) 4 [1.0, 1.1] 5 [1.0, 1.2] <p>These levels introduce realistic signal fluctuations, making augmented data more robust and diverse.</p>"},{"location":"config/#summary","title":"Summary","text":"<p>The <code>config.py</code> file defines parameter constraints for signal transformations, noise modeling, and device-specific characteristics. It provides: 1. Device-Specific Ranges: Ensuring generated signals stay within real-world constraints. 2. Parameter Sweeps: Predefined ranges for augmentations like time shifts, warping, and gain variation. 3. Noise Functions: Modulation techniques for introducing realistic noise evolution. 4. Noise Power &amp; Amplitude Modulation Levels: Randomized variability controls for robust signal augmentation.</p>"},{"location":"contributing/","title":"Contributing to SigVarGen","text":"<p>Thank you for considering contributing to SigVarGen! We welcome contributions of all kinds, whether it's bug fixes, new features, documentation improvements, or general maintenance. This guide outlines how to contribute effectively to the project.</p>"},{"location":"contributing/#issue-tracking-discussion","title":"Issue Tracking &amp; Discussion","text":"<ul> <li>Before submitting a new feature request or bug report, check if an issue already exists.</li> <li>Use labels (<code>bug</code>, <code>enhancement</code>, <code>documentation</code>, etc.) when opening issues.</li> <li>For questions, start a discussion in the Discussions tab.</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<ol> <li>Navigate to the SigVarGen repository: <pre><code>git clone https://github.com/SigVarGen/SigVarGen.git\ncd SigVarGen\n</code></pre></li> <li>Create a new branch for your feature or fix: <pre><code>git checkout -b feature-branch\n</code></pre></li> <li>Set up the development environment: <pre><code>pip install -r requirements.txt\n</code></pre></li> </ol>"},{"location":"contributing/#2-make-your-changes","title":"2. Make Your Changes","text":"<ul> <li>Ensure code is well-structured, readable, and follows the project's style guidelines.</li> <li>Run tests before committing your changes:    <pre><code>pytest tests/\n</code></pre></li> </ul>"},{"location":"contributing/#3-submit-a-pull-request-pr","title":"3. Submit a Pull Request (PR)","text":"<ol> <li>Push your branch to your fork: <pre><code>git push origin feature-branch\n</code></pre></li> <li>Open a Pull Request from GitHub\u2019s UI.</li> <li>Provide a clear title and description explaining the change.</li> <li>Request a review from maintainers.</li> <li>Ensure CI tests pass before merging.</li> </ol>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>Use a structured commit message format: <pre><code>&lt;COMMIT_TYPE&gt;: &lt;Short, descriptive summary&gt;\n</code></pre></p>"},{"location":"contributing/#commit-types","title":"Commit Types","text":"Type Description FEAT Adding a new feature or enhancement. Example: <code>FEAT: Added baseline drift and vectorized signal generation</code> BUG Bug fixes. Example: <code>BUG: Corrected frequency scaling bug</code> TEST Adding or modifying tests (without changing functionality). Example: <code>TEST: Added unit tests for place_interrupt()</code> DOC Documentation updates. Example: <code>DOC: Updated README and added example notebook</code> CHORE General maintenance, refactoring, code style, config updates, or build/CI changes. Example: <code>CHORE: Reformatted with Black and updated CI pipeline</code> SEC Security fixes. Example: <code>SEC: Updated dependency to fix vulnerability</code> RELEASE Version bumps and release preparation. Example: <code>RELEASE: Prepare for 1.1.0 release</code>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Ensure all tests pass before submitting a PR.</li> <li>Run unit tests using pytest:    <pre><code>pytest tests/\n</code></pre></li> <li>If adding new functionality, include relevant tests.</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to SigVarGen, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"contributing/#thank-you-for-contributing-to-sigvargen-your-help-makes-this-project-better","title":"\ud83c\udf89 Thank you for contributing to SigVarGen! Your help makes this project better. \ud83d\ude80","text":""},{"location":"getting_started/","title":"Getting Started","text":"<p>This guide outlines the installation process and environment requirements for using SigVarGen.</p>"},{"location":"getting_started/#python-environment-and-dependencies","title":"Python Environment and Dependencies","text":"<p>SigVarGen requires:</p> <ul> <li>Python &gt;= 3.8</li> <li>NumPy: Numerical computations</li> <li>SciPy: Advanced scientific computations and signal processing</li> <li>Matplotlib: Data visualization</li> <li>pytest: Testing and validation</li> </ul> <p>Dependencies are managed using a standardized <code>pyproject.toml</code>.</p>"},{"location":"getting_started/#installation-instructions","title":"Installation Instructions","text":"<p>Clone and install dependencies:</p> <pre><code>git clone https://github.com/SigVarGen/SigVarGen.git\ncd SigVarGen\npip install ./\n</code></pre>"},{"location":"modules/","title":"Modules Overview","text":"<p>The SigVarGen framework is modular, promoting clarity, maintainability, and scalability. It comprises the following modules:</p> <ul> <li>Signal: Base signal generation, interruptions generation and scheduling, periodic and semi-periodic events.</li> <li>Noise: Noise generation, modeling and addition.</li> <li>Variations: Augmentation techniques such as baseline drift, time warping, and modulation.</li> <li>Configuration: Parameter examples for signal generation, noise modelling and chained augmentation.</li> <li>Utils: Auxiliary functions for signal normalization, metric calculation, and device parameter generation.</li> </ul>"},{"location":"modules/#signal-module-functions-hierarchy-overview","title":"Signal Module Functions Hierarchy Overview","text":"<p>The table below illustrates the relationships between the functions of signal generation. Main functions for this module are <code>generate_signal</code> and <code>add_interrupt_with_params</code>.</p> Level Function Name Role &amp; Dependencies High-Level (Wrappers) <code>add_interrupt_with_params</code> Master function managing all interruptions. Calls <code>add_main_interrupt</code>, <code>add_smaller_interrupts</code> <code>add_main_interrupt</code> Inserts the main interrupt. Calls <code>generate_main_interrupt</code>, <code>place_interrupt</code>, <code>apply_interrupt_modifications</code>, <code>blend_signal</code>, <code>add_complexity_to_inter</code> <code>add_smaller_interrupts</code> Adds secondary small interrupts. Calls <code>generate_main_interrupt</code>, <code>place_interrupt</code>, <code>apply_interrupt_modifications</code>, <code>blend_signal</code> <code>add_interrupt_bursts</code> Adds multiple small bursts. Calls <code>generate_signal</code>, <code>place_interrupt</code>, <code>blend_signal</code> <code>add_periodic_interrupts</code> Adds periodic interruptions to a signal. Calls <code>generate_semi_periodic_signal</code> Mid-Level (Core Operations) <code>generate_main_interrupt</code> Generates sinusoidal-based interruptions. Calls <code>generate_signal</code> <code>place_interrupt</code> Finds placement indexes. Calls <code>get_non_overlapping_interval</code> if needed <code>apply_interrupt_modifications</code> Modifies an interrupt (amplitude shift, drift). Calls <code>apply_baseline_drift_middle_peak</code> if <code>disperse=True</code> <code>add_complexity_to_inter</code> Inserts small overlapping interruptions into the main interrupt <code>generate_semi_periodic_signal</code> Generates a semi-periodic binary signal with random bit flips Low-Level (Utilities) <code>generate_signal</code> Creates multi-sinusoidal signals <code>blend_signal</code> Merges base and interrupt signals. Used across multiple functions <code>get_non_overlapping_interval</code> Ensures new interruptions do not overlap"},{"location":"modules/#noise-module-functions-hierarchy-overview","title":"Noise Module Functions Hierarchy Overview","text":"<p>The main functions for noise module are <code>add_colored_noise</code> and <code>generate_noise_power</code>, which enable controlled noise injection and spectral shaping.</p> Level Function Name Role &amp; Dependencies High-Level (Wrappers) <code>add_colored_noise</code> Generates and adds noise with a specific spectral profile (white, pink, or brown) to a signal. Can apply an envelope for non-stationary noise effects. Mid-Level (Core Operations) <code>generate_noise_power</code> Computes noise power based on a selected SNR. Determines variance for controlled noise injection. Low-Level (Utilities) <code>envelope_linear</code> Generates a linearly increasing or decreasing noise amplitude envelope. <code>envelope_sine</code> Applies periodic modulation to noise amplitude using a sine wave. <code>envelope_random_walk</code> Introduces stochastic variations in noise amplitude, simulating unpredictable fluctuations. <code>envelope_blockwise</code> Creates stepwise variations in noise intensity, mimicking abrupt environmental changes."},{"location":"modules/#variation-module-functions-hierarchy-overview","title":"Variation Module Functions Hierarchy Overview","text":"<p>The variation module applies time, amplitude and baseline transformations with segment substitution to introduce realistic signal variations. The primary functions are <code>generate_variation</code> and <code>generate_parameter_variations</code>, which manage systematic augmentation of signals through transformations.</p> Level Function Name Role &amp; Dependencies High-Level (Wrappers) <code>generate_variation</code> Applies a sequence of transformations (time shifts, warping, amplitude modulation, drift) to create signal variations. Depends on multiple transformation functions. <code>generate_parameter_variations</code> Generates randomized parameter sets for transformations, ensuring controlled variability across multiple signal instances. Mid-Level (Core Transformations) <code>apply_time_shift</code> Introduces a random time delay or advance in the waveform. <code>apply_time_warp</code> Modifies the time axis non-linearly, stretching or compressing signal segments. <code>apply_gain_variation</code> Adjusts signal amplitude by applying a multiplicative gain factor. <code>apply_amplitude_modulation</code> Introduces periodic amplitude changes across the full signal. <code>apply_amplitude_modulation_region</code> Modulates amplitude only within a specified signal region. Low-Level (Baseline Drift Operations) <code>apply_baseline_drift</code> Adds a global linear drift to the waveform, simulating gradual baseline shifts. <code>apply_baseline_drift_region</code> Introduces localized baseline drift within a specific segment of the waveform. <code>apply_baseline_drift_middle_peak</code> Creates a baseline drift that peaks at the center of the signal. <code>apply_baseline_drift_polynomial</code> Applies a polynomial baseline drift across the signal for nonlinear baseline changes. <code>apply_baseline_drift_piecewise</code> Introduces stepwise changes in baseline level across different signal segments. Low-Level (Segment Transformations) <code>transform_wave_with_score</code> Replaces parts of a signal with newly generated segments based on a probability score. Low-Level (Noise &amp; Quantization) <code>apply_quantization_noise</code> Simulates digital quantization effects by reducing bit depth, introducing quantization noise."},{"location":"modules/#utilities-module-functions-hierarchy-overview","title":"Utilities Module Functions Hierarchy Overview","text":"<p>The utils module contains general-purpose signal processing functions used for normalization, interpolation, and metric calculations.</p> Level Function Name Role &amp; Dependencies High-Level (Device Parameter Processing) <code>generate_device_parameters</code> Splits device frequency and amplitude constraints into two distinct ranges for controlled simulations. Mid-Level (Metric Computation) <code>calculate_SNR</code> Computes the signal-to-noise ratio (SNR) between a clean signal and a noisy version. <code>calculate_ED</code> Computes the Euclidean distance (ED) between two signals. Low-Level (Signal Processing &amp; Normalization) <code>interpoling</code> Interpolates a signal to a target length, ensuring uniform sampling across signals. <code>normalization</code> Standardizes a signal by centering it at zero mean and unit variance."},{"location":"modules/#configuration-module-overview","title":"Configuration Module Overview","text":"<p>The config module contains predefined device-specific amplitude and frequency constraints and parameter sweep definitions for signal variation experiments. It ensures systematic parameter selection across different devices and experimental conditions.</p> Level Parameter Set Role &amp; Details Device-Specific Constraints <code>EMBEDDED_DEVICE_RANGES</code> Defines amplitude and frequency constraints for various embedded devices (Arduino, drones, cameras, IoT, automotive sensors, etc.). Ensures signal generation remains within realistic ranges. Experimental Parameter Sweeps <code>param_sweeps</code> Defines parameter ranges for signal variations, including time shift, time warp, amplitude modulation, baseline drift, and gain variation. Allows controlled random selection of transformation parameters for signal augmentation. Noise Envelopes <code>noise_funcs</code> Defines time-varying noise envelopes (linear, sine, random walk, and blockwise modulation) used to simulate non-stationary noise conditions. Noise Power Variation Levels <code>npw_levels</code> Defines multiplicative noise power variations for added noise intensity fluctuations. Modulation Factor Levels <code>mf_levels</code> Defines modulation factor variations, ensuring subtle randomized amplitude fluctuations in generated signals."},{"location":"noise/","title":"Noise Module","text":"<p>The Noise Module provides methods for generating and adding noise to signals, enabling the simulation of realistic noisy environments for signal processing applications. Noise is an inherent part of real-world signals, originating from various sources such as electronic interference, environmental fluctuations, or stochastic variations in a system. In many cases, noise is considered an undesirable artifact that must be reduced or removed. However, noise can also carry valuable information about the system\u2019s state or environment.</p> <p>The module supports stationary and non-stationary noise models, including:</p> <ul> <li>Colored noise synthesis (white, pink, and brown).</li> <li>Time-varying noise envelopes (linear, sinusoidal, random walk, and blockwise modulation).</li> <li>Controlled noise injection using signal-to-noise ratio (SNR) scaling.</li> </ul> <p>These methods allow users to introduce realistic noise patterns into their signals, useful for testing denoising algorithms, training machine learning models, and modeling real-world scenarios.</p>"},{"location":"noise/#conceptual-overview","title":"Conceptual Overview","text":""},{"location":"noise/#understanding-noise-characteristics","title":"Understanding Noise Characteristics","text":"<p>Noise can be broadly classified into stationary and non-stationary types:</p> <ul> <li> <p>Stationary Noise: Statistical properties (e.g., variance, mean, and spectral density) remain constant over time.   Examples: Thermal noise in electrical circuits, Gaussian noise in images.  </p> </li> <li> <p>Non-Stationary Noise: Statistical properties vary over time, often due to changing environmental factors or system dynamics.   Examples: Wind noise in microphones, motion artifacts in biomedical signals.</p> </li> </ul> <p>Many natural noise sources follow a power-law spectral density, where spectral power decreases as a function of frequency. This principle, observed in fractal and chaotic systems, is the basis for colored noise synthesis.</p>"},{"location":"noise/#colored-noise-synthesis","title":"Colored Noise Synthesis","text":"<p>The Noise Module implements a Fourier-based noise synthesis method, introduced by Poul Bourke (1997), which follows these steps:</p> <ol> <li>Generate a white noise sequence in the time domain.</li> <li>Transform the noise into the frequency domain using the Fourier transform.</li> <li>Apply a spectral filter to shape the noise power based on the desired frequency-dependent function \\( 1/f^p \\).</li> <li>Perform an inverse Fourier transform to reconstruct the time-domain noise.</li> </ol> <p>This approach allows the generation of different noise types:</p> <ul> <li>White noise (\\( p=0 \\)) \u2192 Equal power at all frequencies.</li> <li>Pink noise (\\( p=1 \\)) \u2192 Power decreases as \\( 1/f \\), common in biological signals.</li> <li>Brown noise (\\( p=2 \\)) \u2192 Power decreases as \\( 1/f^2 \\), with stronger low-frequency components.</li> </ul> <p>$$ S(f) \\propto \\frac{1}{f^p}, $$ where \\( S(f) \\) represents the spectral power density and \\( p \\) determines the noise color.</p>"},{"location":"noise/#envelope-based-noise-modulation","title":"Envelope-Based Noise Modulation","text":"<p>To introduce non-stationary noise effects, the module supports four amplitude modulation envelopes:</p> <ol> <li>Linear Envelope \u2192 Gradually increases or decreases noise intensity over time.</li> <li>Sine Envelope \u2192 Modulates noise amplitude periodically, introducing cyclic variations.</li> <li>Random Walk Envelope \u2192 Introduces stochastic amplitude changes, simulating unpredictable real-world fluctuations.</li> <li>Blockwise Envelope \u2192 Produces abrupt, step-like noise intensity variations.</li> </ol> <p>These envelopes enable controlled noise dynamics, making the generated noise adaptable to real-world non-stationary environments.</p>"},{"location":"noise/#references","title":"References","text":"<ol> <li>Celka, P. (2006). Smoothly Time-Varying AR Models and Applications in Biomedical Signal Processing.  </li> <li>Vaseghi, S. (2008). Advanced Digital Signal Processing and Noise Reduction. Wiley.  </li> <li>Bourke, P. (1997). Frequency Synthesis of Landscapes (and Clouds).  </li> <li>Mitrovic, D. et al. (2010). Analysis and Generation of Synthetic Colored Noise for Machine Learning Applications.  </li> </ol>"},{"location":"signal/","title":"Signal Module","text":"<p>The Signal Module focuses on generating and managing synthetic waveforms. Central to its operation is the principle that any aperiodic signal can be approximated by a sum of sinusoidal components (Fourier Transform theory). In essence, complex real\u2011world signals, not strictly periodic, can be well\u2011represented or approximated by a set of sinusoidal basis functions.</p>"},{"location":"signal/#conceptual-overview","title":"Conceptual Overview","text":""},{"location":"signal/#constructing-base-signals","title":"Constructing Base Signals","text":"<p>Signals are typically created by crafting a foundational sinusoidal waveform with possible sporadic interruptions. The base signals are formed by overlaying multiple sinusoidal waves. According to Fourier analysis, any periodic signal can be decomposed into pure sinusoidal components. Extending that concept, an aperiodic signal can be artificially treated as periodic by repetition over a long period \\( T_0 \\), enabling a similar decomposition. As \\( T_0 \\) approaches infinity, the discrete spectral components merge into the continuous Fourier Transform.</p> \\[ x_P(t) = \\sum_{n=-\\infty}^{\\infty} C_n e^{j 2\\pi n f_0 t}, \\] <p>where \\( C_n \\) are coefficients defined by:</p> \\[ C_n = \\frac{1}{T_0} \\int_{-T_0/2}^{T_0/2} x_P(t) e^{-j 2\\pi n f_0 t} \\, dt. \\] <p>In the limit as \\( T_0 \\to \\infty \\), these expressions become the standard Fourier Transform for aperiodic signals, justifying the construction of complex synthetic signals from purely sinusoidal forms.</p>"},{"location":"signal/#references","title":"References","text":"<ol> <li>S. D. Apte (2016). Fourier Transform Representation of Aperiodic Signals. In Signals and Systems: Principles and Applications (pp. 409\u2013512). Cambridge University Press.  </li> <li>Fourier\u2019s theorem and the spectrum of complex tones. (2023). Retrieved from https://mtsu.edu/faculty/wroberts/teaching/fourier_4.php.  </li> <li>Haslwanter, T. (2021). Hands-on Signal Analysis with Python. Springer.</li> </ol>"},{"location":"utils/","title":"Utils Module","text":""},{"location":"utils/#utilspy","title":"<code>utils.py</code>","text":"<p>Location: <code>utils.py</code></p>"},{"location":"utils/#description","title":"Description","text":"<p>The <code>utils.py</code> module provides helper functions for signal processing, normalization, interpolation, and device-specific parameter management. These functions support the core operations of the framework by offering signal evaluation, transformation, and metadata generation.</p> <p>The main functionalities include: - Signal quality assessment (e.g., Signal-to-Noise Ratio, Euclidean Distance) - Signal normalization and interpolation - Device-specific parameter management, allowing controlled variations in amplitude and frequency constraints.</p>"},{"location":"utils/#functions","title":"Functions","text":""},{"location":"utils/#calculate_snr","title":"<code>calculate_SNR</code>","text":"<p>Computes the Signal-to-Noise Ratio (SNR) between a clean signal and its noisy version.</p> <p>Parameters: - <code>signal</code> (<code>numpy.ndarray</code>): Original signal. - <code>noisy_signal</code> (<code>numpy.ndarray</code>): Noisy version of the signal.</p> <p>Returns: - <code>snr_db</code> (<code>float</code>): Signal-to-noise ratio in decibels (dB).</p> <p>Example: <pre><code>snr = calculate_SNR(clean_signal, noisy_signal)\nprint(f\"SNR: {snr:.2f} dB\")\n</code></pre></p>"},{"location":"utils/#calculate_ed","title":"<code>calculate_ED</code>","text":"<p>Computes the Euclidean Distance (ED) between two signals.</p> <p>Parameters: - <code>X</code> (<code>numpy.ndarray</code>): First signal. - <code>Y</code> (<code>numpy.ndarray</code>): Second signal.</p> <p>Returns: - <code>ed</code> (<code>float</code>): Euclidean distance between <code>X</code> and <code>Y</code>.</p> <p>Example: <pre><code>ed = calculate_ED(signal1, signal2)\nprint(f\"Euclidean Distance: {ed}\")\n</code></pre></p>"},{"location":"utils/#interpoling","title":"<code>interpoling</code>","text":"<p>Performs linear interpolation to adjust a signal to a target length.</p> <p>Parameters: - <code>res</code> (<code>numpy.ndarray</code>): Input signal to be interpolated. - <code>target_len</code> (<code>int</code>, optional): Desired output length (default: <code>10000</code>).</p> <p>Returns: - <code>numpy.ndarray</code>: Interpolated signal.</p> <p>Example: <pre><code>resampled_signal = interpoling(signal, target_len=5000)\n</code></pre></p>"},{"location":"utils/#normalization","title":"<code>normalization</code>","text":"<p>Performs z-score normalization on a signal, ensuring zero mean and unit variance.</p> <p>Parameters: - <code>signal1</code> (<code>numpy.ndarray</code>): Input signal.</p> <p>Returns: - <code>numpy.ndarray</code>: Normalized signal.</p> <p>Example: <pre><code>normalized_signal = normalization(raw_signal)\n</code></pre></p>"},{"location":"utils/#generate_device_parameters","title":"<code>generate_device_parameters</code>","text":"<p><code>generate_device_parameters</code> splits the amplitude and frequency ranges of device configurations into two distinct subsets. This allows for controlled variations in device constraints, which is useful for simulating different operating conditions or testing parameter-dependent behaviors in signal processing tasks.</p> <p>By adjusting the split ratio, users can control the proportion of the parameter space assigned to each subset. Additionally, the function can: - Preserve full frequency ranges for both subsets or - Split frequency ranges proportionally with amplitude constraints.</p>"},{"location":"utils/#notes","title":"Notes","text":"<ul> <li>If <code>drop=False</code>, the first subset receives the lower amplitude range, and the second subset gets the higher amplitude range.</li> <li>If <code>drop=True</code>, the assignment is reversed.</li> <li>If <code>frequency_follows_amplitude=True</code>, frequency ranges are split along with amplitude.</li> <li>If <code>frequency_follows_amplitude=False</code>, both subsets retain the full frequency range.</li> <li>A <code>split_ratio</code> of <code>0.5</code> evenly distributes the parameter space between the two subsets.</li> </ul>"},{"location":"utils/#parameters","title":"Parameters","text":"<ul> <li>device_params (<code>dict</code>):   Dictionary containing device parameter configurations.   Each entry should include:</li> <li><code>'amplitude'</code>: Tuple (min, max) voltage levels.</li> <li> <p><code>'frequency'</code>: Tuple (min, max) frequency range or a nested dictionary of frequency bands.</p> </li> <li> <p>drop (<code>bool</code>, optional):  </p> </li> <li><code>False</code> \u2192 First dictionary gets lower amplitude range.  </li> <li> <p><code>True</code> \u2192 First dictionary gets upper amplitude range. Default: <code>False</code>.</p> </li> <li> <p>frequency_follows_amplitude (<code>bool</code>, optional):  </p> </li> <li><code>True</code> \u2192 Frequency ranges split proportionally to amplitude.  </li> <li> <p><code>False</code> \u2192 Both subsets retain full frequency range. Default: <code>True</code>.</p> </li> <li> <p>split_ratio (<code>float</code>, optional):   Fraction (0.0 to 1.0) defining how much of the range is assigned to the first subset.  </p> </li> <li><code>0.0</code> \u2192 All values go to the second subset.  </li> <li><code>1.0</code> \u2192 All values go to the first subset. Default: <code>0.5</code>.</li> </ul>"},{"location":"utils/#returns","title":"Returns","text":"<ul> <li> <p>lower_params (<code>dict</code>):   Dictionary containing lower-range parameter configurations.</p> </li> <li> <p>upper_params (<code>dict</code>):   Dictionary containing upper-range parameter configurations.</p> </li> </ul>"},{"location":"utils/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen.utils as utils\n\n# Example device parameters\ndevice_params = {\n    'Arduino Board': {\n        'amplitude': (0, 5),  # Voltage range\n        'frequency': (0, 12e3)  # Hz\n    },\n    'Drones': {\n        'amplitude': (0, 1),  # Voltage range\n        'frequency': {\n            'control': (2.398e9, 2.402e9),  # Hz\n            'telemetry_low': (432e6, 434e6),  # Hz\n            'telemetry_high': (2.39e9, 5.9e9)  # Hz\n        }\n    }\n}\n\n# Generate parameter subsets with a 60/40 split and frequency following amplitude\nlower_params, upper_params = utils.generate_device_parameters(\n    device_params, drop=False, split_ratio=0.6\n)\n\nprint(\"Lower Parameter Set:\", lower_params)\nprint(\"Upper Parameter Set:\", upper_params)\n</code></pre>"},{"location":"utils/#summary","title":"Summary","text":"<p>The <code>utils.py</code> module provides essential support functions for signal transformation, evaluation, and device-specific parameter handling. These functions enhance signal processing workflows and ensure realistic device constraints for generated signals.</p>"},{"location":"variations/","title":"Variations Module","text":"<p>The Variations Module provides transformations that introduce controlled distortions in time, amplitude, and baseline characteristics of a signal. These transformations simulate real-world variations encountered in repeated measurements due to environmental dynamics, sensor drift, and system instabilities. By incorporating parameter space exploration, this module ensures a systematic and randomized approach to generating diverse signal variants.</p> <p>The module is essential for robust testing of signal processing algorithms, particularly in machine learning, adaptive filtering, and anomaly detection, where real-world data is often subject to dynamic changes.</p>"},{"location":"variations/#conceptual-overview","title":"Conceptual Overview","text":""},{"location":"variations/#simulating-measurement-variability","title":"Simulating Measurement Variability","text":"<p>In real-world signal acquisition, repeated measurements of the same event often differ due to internal system variations, environmental factors, or sensor-specific perturbations. These variations can be global (affecting the entire signal)** or localized (affecting only certain segments of the signal). The Variations Module captures these effects through two key processes:</p> <ol> <li> <p>Parameter-Based Transformations    The <code>generate_parameter_variations</code> function selects randomized parameter values from predefined ranges to simulate natural signal variations across multiple measurements.</p> </li> <li> <p>Signal Transformations    The <code>generate_variation</code> function applies a sequence of transformations, including:</p> </li> <li>Time distortions (shifting, warping)</li> <li>Amplitude variations (gain changes, modulation)</li> <li>Baseline drift (global, regional, and polynomial-based shifts)</li> <li>Localized distortions (temporary amplitude changes, quantization noise)</li> <li>Wave Transformation with Score-Based Replacement (controlled signal modification)</li> </ol> <p>These transformations allow for the realistic augmentation of time-series data, making them well-suited for data augmentation, robustness testing, and synthetic dataset generation.</p>"},{"location":"variations/#time-based-variations","title":"Time-Based Variations","text":"<p>Time-domain transformations modify the timing or structure of the signal to simulate sensor delays, data misalignment, or speed variations.</p> <ul> <li>Time Shift: Circularly shifts the waveform within a defined interval, mimicking synchronization errors or acquisition delays.</li> <li>Time Warp: Non-linearly compresses or expands parts of the signal to replicate speed variations or non-uniform time distortions.</li> </ul>"},{"location":"variations/#amplitude-based-variations","title":"Amplitude-Based Variations","text":"<p>Amplitude transformations alter signal intensity to model sensor gain fluctuations, environmental effects, or periodic modulation.</p> <ul> <li>Gain Variation: Randomly scales the waveform amplitude to simulate variable sensor sensitivity.</li> <li>Amplitude Modulation: Applies a sinusoidal modulation effect, replicating cyclic variations in signal intensity.</li> </ul>"},{"location":"variations/#baseline-drift-variations","title":"Baseline Drift Variations","text":"<p>Baseline drift introduces long-term shifts in the signal, reflecting slowly changing environmental factors or sensor drift.</p> <ul> <li>Global Drift: Affects the entire signal with a linear or polynomial trend.</li> <li>Regional Drift: Applies drift only to specific sections of the signal, simulating localized sensor instability.</li> <li>Middle Peak Drift: Introduces a centered peak shift, modeling temporary disturbances.</li> </ul>"},{"location":"variations/#wave-transformation-with-score-based-replacement","title":"Wave Transformation with Score-Based Replacement","text":"<ul> <li>Transform Wave with Score: Replaces parts of the original waveform with segments of newly generated signals based on a predefined probability. This allows controlled localized waveform modification, making it useful for simulating partial signal corruption, data loss, or adaptive feature modification in real-world signals.</li> </ul>"},{"location":"functions/noise/1generate_noise_power/","title":"generate_noise_power","text":""},{"location":"functions/noise/1generate_noise_power/#generate_noise_power","title":"<code>generate_noise_power</code>","text":"<p>Location: <code>noise/noise.py</code></p>"},{"location":"functions/noise/1generate_noise_power/#description","title":"Description","text":"<p><code>generate_noise_power</code> calculates the noise power (variance) for a given signal based on a randomly selected signal-to-noise ratio (SNR) from a specified range. This function enables controlled noise injection, allowing for precise simulation of noisy environments in signal processing applications.</p> <p>By selecting an SNR value and computing the corresponding noise power, the function ensures that the noise level is appropriately scaled relative to the signal's amplitude. This is useful for testing denoising algorithms, simulating real-world measurement noise, and augmenting synthetic datasets.</p>"},{"location":"functions/noise/1generate_noise_power/#notes","title":"Notes","text":"<ul> <li>The function selects an SNR value (in dB) randomly within the specified range.</li> <li>A higher SNR results in lower noise power, preserving signal clarity.</li> <li>A lower SNR introduces stronger noise, making the signal more distorted.</li> <li>The noise power is computed as the variance of the noise signal required to achieve the selected SNR.</li> <li>Colored and non-stationary noise can introduce frequency-selective distortions or dynamic fluctuations that are not reflected by a simple SNR value. </li> </ul>"},{"location":"functions/noise/1generate_noise_power/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input signal from which noise power will be computed.</p> </li> <li> <p>snr_range (<code>tuple</code> of <code>int</code>, optional):   The range of SNR values (in dB) from which a value is randomly selected.  </p> </li> <li>Default: <code>(-20, 30)</code> (low to high SNR scenarios).  </li> <li>Example: <code>(-10, 20)</code> simulates moderate noise levels.</li> </ul>"},{"location":"functions/noise/1generate_noise_power/#returns","title":"Returns","text":"<ul> <li> <p>noise_power (<code>float</code>):   The computed noise power (variance) based on the selected SNR.</p> </li> <li> <p>selected_snr_db (<code>float</code>):   The randomly selected SNR (in dB), useful for reference.</p> </li> </ul>"},{"location":"functions/noise/1generate_noise_power/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Generate a synthetic sine wave\nt = np.linspace(0, 1, 1000)\nclean_signal = np.sin(2 * np.pi * 5 * t)\n\n# Compute noise power with a random SNR in the range (-10, 20) dB\nnoise_power, snr_db = svg.generate_noise_power(clean_signal, snr_range=(-10, 20))\n\nprint(f\"Selected SNR: {snr_db} dB\")\nprint(f\"Computed Noise Power: {noise_power}\")\n</code></pre>"},{"location":"functions/noise/2add_colored_noise/","title":"add_colored_noise","text":""},{"location":"functions/noise/2add_colored_noise/#add_colored_noise","title":"<code>add_colored_noise</code>","text":"<p>Location: <code>noise/noise_addition.py</code></p>"},{"location":"functions/noise/2add_colored_noise/#description","title":"Description","text":"<p><code>add_colored_noise</code> introduces noise (white, pink, or brown) into a signal, simulating realistic noisy environments. This function applies frequency-domain filtering to generate colored noise with specific spectral properties and then scales it to a defined noise power level.</p> <p>Additionally, an optional modulation envelope can be applied, introducing time-dependent amplitude variations that mimic real-world non-stationary noise patterns. This makes the function valuable for signal augmentation, testing noise-robust algorithms, and creating realistic simulations of environmental interference.</p>"},{"location":"functions/noise/2add_colored_noise/#notes","title":"Notes","text":"<ul> <li>White noise has a flat power spectrum across all frequencies.</li> <li>Pink noise follows a \\(1/f\\) spectral decay, often found in natural and biological systems.</li> <li>Brown noise follows a \\(1/f^2\\) spectral decay, emphasizing lower frequencies.</li> <li>The noise power is adjusted relative to the input signal using a specified SNR range.</li> <li>Applying a modulation envelope allows for non-stationary noise characteristics.</li> </ul>"},{"location":"functions/noise/2add_colored_noise/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The original signal to which noise will be added.</p> </li> <li> <p>noise_power (<code>float</code>):   The base noise power level, determining the variance of the added noise.</p> </li> <li> <p>npw (<code>tuple</code> of <code>float</code>):   A range (<code>min</code>, <code>max</code>) defining noise power variation, allowing randomness in noise intensity between different measurements.</p> </li> <li> <p>mf (<code>tuple</code> of <code>float</code>):   A range (<code>min</code>, <code>max</code>) defining the modulation factor variation, slightly altering the signal amplitude between different measurements.</p> </li> <li> <p>color (<code>str</code>, optional):   Type of noise to add:  </p> </li> <li><code>'white'</code> \u2192 Equal power at all frequencies.  </li> <li><code>'pink'</code> \u2192 Power decays as \\(1/f\\), common in speech and natural signals.  </li> <li> <p><code>'brown'</code> \u2192 Power decays as \\(1/f^2\\), emphasizing low frequencies. Default: <code>'pink'</code>.</p> </li> <li> <p>mod_envelope (<code>dict</code>, optional):   Dictionary specifying a time-varying amplitude envelope for non-stationary noise:  </p> </li> <li><code>'func'</code>: The envelope function.  </li> <li><code>'param'</code>: Range of parameters for the envelope function.     If <code>None</code>, noise remains stationary. Default: <code>None</code>.     Parameter examples provided in <code>config.py</code>.</li> </ul>"},{"location":"functions/noise/2add_colored_noise/#returns","title":"Returns","text":"<ul> <li> <p>res (<code>numpy.ndarray</code>):   The input signal with added colored noise.</p> </li> <li> <p>noise (<code>numpy.ndarray</code>):   The isolated noise component, useful for separate analysis or denoising techniques.</p> </li> </ul>"},{"location":"functions/noise/2add_colored_noise/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Generate a clean sine wave\nt = np.linspace(0, 1, 1000)\nclean_signal = np.sin(2 * np.pi * 5 * t)\n\n# Define noise parameters\nnoise_power = 0.05\nnpw_range = (1, 1.1)\nmf_range = (1, 1) \n\n# Add pink noise with a sine modulation envelope\nnoisy_signal, noise = svg.add_colored_noise(\n    wave=clean_signal,\n    noise_power=noise_power,\n    npw=npw_range,\n    mf=mf_range,\n    color=\"pink\",\n    mod_envelope={\"func\": svg.envelope_sine, \"param\": [0.01, 0.015]} \n)\n\nprint(\"Noisy Signal Shape:\", noisy_signal.shape)\n</code></pre>"},{"location":"functions/noise/3envelopes/","title":"envelopes","text":""},{"location":"functions/noise/3envelopes/#envelopes-for-noise-modulation","title":"Envelopes for Noise Modulation","text":"<p>The envelope functions in the Noise Module modify the amplitude of noise signals over time, simulating real-world non-stationary noise patterns. These functions introduce gradual or abrupt variations in noise intensity, making the generated noise more realistic for applications in signal processing, machine learning, and system testing.</p> <p>Each envelope function follows a unique pattern: - Linear: Gradual increase or decrease in noise amplitude. - Sine: Periodic oscillations in amplitude. - Random Walk: Stochastic variations mimicking unpredictable changes. - Blockwise: Sudden step-like changes in amplitude.</p> <p>These envelopes allow dynamic control over noise behavior, enhancing the realism of simulated noisy environments.</p>"},{"location":"functions/noise/3envelopes/#envelope-functions-overview","title":"Envelope Functions Overview","text":""},{"location":"functions/noise/3envelopes/#envelope_linear","title":"<code>envelope_linear</code>","text":"<p>Location: <code>noise/envelopes.py</code></p>"},{"location":"functions/noise/3envelopes/#description","title":"Description","text":"<p><code>envelope_linear</code> generates a linearly changing amplitude envelope, transitioning smoothly between two defined noise power levels. Depending on the <code>param</code> value, the envelope either ramps up or ramps down over time.</p>"},{"location":"functions/noise/3envelopes/#parameters","title":"Parameters","text":"<ul> <li>num_samples (<code>int</code>):   Number of samples in the envelope (must match the signal length).</li> <li>npw (<code>tuple</code> of <code>float</code>): <code>(min, max)</code> range of noise power values.</li> <li>param (<code>float</code>):   Controls the direction of the transition:  </li> <li><code>&gt; 0.5</code> \u2192 Increasing envelope.  </li> <li><code>\u2264 0.5</code> \u2192 Decreasing envelope.</li> </ul>"},{"location":"functions/noise/3envelopes/#returns","title":"Returns","text":"<ul> <li>envelope (<code>numpy.ndarray</code>):   Linearly increasing or decreasing amplitude envelope.</li> </ul>"},{"location":"functions/noise/3envelopes/#example","title":"Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\nenv = svg.envelope_linear(num_samples=1000, npw=(0.1, 1.0), param=0.7)\nprint(env[:10])  # First 10 values of the envelope\n</code></pre>"},{"location":"functions/noise/3envelopes/#envelope_sine","title":"<code>envelope_sine</code>","text":"<p>Location: <code>noise/envelopes.py</code></p>"},{"location":"functions/noise/3envelopes/#description_1","title":"Description","text":"<p><code>envelope_sine</code> applies periodic modulation to noise amplitude, creating fluctuations that mimic oscillatory environmental effects. This envelope is particularly useful for simulating periodic disturbances such as wind noise or cyclic variations in signal intensity.</p>"},{"location":"functions/noise/3envelopes/#parameters_1","title":"Parameters","text":"<ul> <li>num_samples (<code>int</code>):   Number of samples in the envelope.</li> <li>npw (<code>tuple</code> of <code>float</code>): <code>(min, max)</code> range of noise power values.</li> <li>param (<code>float</code>, optional, default=<code>0.005</code>):   Frequency of oscillations (lower values result in slower oscillations).</li> </ul>"},{"location":"functions/noise/3envelopes/#returns_1","title":"Returns","text":"<ul> <li>envelope (<code>numpy.ndarray</code>):   Sine wave-modulated amplitude envelope.</li> </ul>"},{"location":"functions/noise/3envelopes/#example_1","title":"Example","text":"<pre><code>env = svg.envelope_sine(num_samples=1000, npw=(0.1, 1.0), param=0.01)\nprint(env[:10])  # First 10 values of the envelope\n</code></pre>"},{"location":"functions/noise/3envelopes/#envelope_random_walk","title":"<code>envelope_random_walk</code>","text":"<p>Location: <code>noise/envelopes.py</code></p>"},{"location":"functions/noise/3envelopes/#description_2","title":"Description","text":"<p><code>envelope_random_walk</code> generates a stochastic amplitude envelope, where the noise power follows a random walk pattern. This mimics unpredictable fluctuations observed in real-world signals, such as biological noise or varying environmental conditions.</p>"},{"location":"functions/noise/3envelopes/#parameters_2","title":"Parameters","text":"<ul> <li>num_samples (<code>int</code>):   Number of samples in the envelope.</li> <li>npw (<code>tuple</code> of <code>float</code>): <code>(min, max)</code> range of noise power values.</li> <li>param (<code>float</code>, optional, default=<code>0.01</code>):   Standard deviation of the random step size (higher values cause more variability).   Higher value results in higher amplitude, which might be clipped.</li> </ul>"},{"location":"functions/noise/3envelopes/#returns_2","title":"Returns","text":"<ul> <li>envelope (<code>numpy.ndarray</code>):   Stochastically varying amplitude envelope.</li> </ul>"},{"location":"functions/noise/3envelopes/#example_2","title":"Example","text":"<pre><code>env = svg.envelope_random_walk(num_samples=1000, npw=(0.1, 1.0), param=0.02)\nprint(env[:10])  # First 10 values of the envelope\n</code></pre>"},{"location":"functions/noise/3envelopes/#envelope_blockwise","title":"<code>envelope_blockwise</code>","text":"<p>Location: <code>noise/envelopes.py</code></p>"},{"location":"functions/noise/3envelopes/#description_3","title":"Description","text":"<p><code>envelope_blockwise</code> applies stepwise variations in noise power, creating block-like intensity changes. This is useful for simulating sudden shifts in noise levels, such as network congestion bursts or machine noise variations.</p>"},{"location":"functions/noise/3envelopes/#parameters_3","title":"Parameters","text":"<ul> <li>num_samples (<code>int</code>):   Number of samples in the envelope.</li> <li>npw (<code>tuple</code> of <code>float</code>): <code>(min, max)</code> range of noise power values.</li> <li>param (<code>int</code>, optional, default=<code>100</code>):   Block size (number of samples per step).</li> </ul>"},{"location":"functions/noise/3envelopes/#returns_3","title":"Returns","text":"<ul> <li>envelope (<code>numpy.ndarray</code>):   Stepwise amplitude envelope.</li> </ul>"},{"location":"functions/noise/3envelopes/#example_3","title":"Example","text":"<pre><code>env = svg.envelope_blockwise(num_samples=1000, npw=(0.1, 1.0), param=50)\nprint(env[:10])  # First 10 values of the envelope\n</code></pre>"},{"location":"functions/signal/10add_interrupt_with_params/","title":"add_interrupt_with_params","text":""},{"location":"functions/signal/10add_interrupt_with_params/#add_interrupt_with_params","title":"<code>add_interrupt_with_params</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/10add_interrupt_with_params/#description","title":"Description","text":"<p><code>add_interrupt_with_params</code> introduces a primary sinusoidal-based interrupt into a signal while optionally embedding smaller and overlapping secondary interrupts. The function ensures that all interrupts adhere to predefined amplitude and frequency constraints, and it allows for configurable properties such as baseline drift, blending, and size variation. This function is useful for generating complex, realistic perturbations in time-series data.</p>"},{"location":"functions/signal/10add_interrupt_with_params/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector for the signal (usually created using <code>np.linspace</code>).  </li> <li>base_signal (<code>numpy.ndarray</code>): The original base signal to be modified.  </li> <li>domain (<code>str</code>): The key used to retrieve amplitude and frequency ranges from <code>INTERRUPT_RANGES</code>.  </li> <li>DEVICE_RANGES (<code>dict</code>): A dictionary containing amplitude and frequency limits for the device.  </li> <li>INTERRUPT_RANGES (<code>dict</code>): A dictionary containing predefined amplitude and frequency ranges for different domains.  </li> <li>temp (<code>int</code>): The index determining which frequency range to use.  </li> <li>drop (<code>bool</code>, optional):  </li> <li>If <code>True</code>, the interrupt is offset downward.  </li> <li>If <code>False</code>, the interrupt is offset upward.  </li> <li>Default: <code>True</code>.  </li> <li>disperse (<code>bool</code>, optional):  </li> <li>If <code>True</code>, applies a varying baseline drift with a peak drift in the middle.  </li> <li>Default: <code>True</code>.  </li> <li>duration_ratio (<code>float</code>, optional):  </li> <li>The fraction of total signal length occupied by the main interrupt.  </li> <li>If <code>None</code>, a random value between <code>0.06</code> and <code>0.12</code> is chosen.  </li> <li>n_smaller_interrupts (<code>int</code>, optional):  </li> <li>The number of smaller interrupts to add.  </li> <li>If <code>None</code>, a random value between <code>0</code> and <code>2</code> is chosen.  </li> <li>n_sinusoids (<code>int</code>, optional):  </li> <li>The number of sinusoidal components in each interrupt.  </li> <li>If <code>None</code>, a random number between <code>2</code> and <code>10</code> is chosen.  </li> <li>non_overlap (<code>bool</code>, optional):  </li> <li>If <code>True</code>, ensures that interrupts do not overlap with previously occupied intervals.  </li> <li>Default: <code>True</code>.  </li> <li>complex_iter (<code>int</code>, optional):  </li> <li>The number of smaller overlapping interrupts embedded within the main interrupt.  </li> <li>Default: <code>0</code>.  </li> <li>blend_factor (<code>float</code>, optional):  </li> <li>The weight used to blend the base and interrupt signals.  </li> <li>Default: <code>0.5</code>.  </li> <li>shrink_complex (<code>bool</code>, optional):  </li> <li>If <code>True</code>, each successive overlapping interrupt shrinks in size.  </li> <li>Default: <code>False</code>.  </li> <li>shrink_factor (<code>float</code>, optional):  </li> <li>The fraction by which each overlapping complex interrupt shrinks.  </li> <li>Default: <code>0.9</code>.  </li> <li>buffer (<code>int</code>, optional):  </li> <li>The minimum spacing (in samples) between interrupts when <code>non_overlap=True</code>.  </li> <li>Default: <code>1</code>.</li> </ul>"},{"location":"functions/signal/10add_interrupt_with_params/#returns","title":"Returns","text":"<ul> <li>updated_base_signal (<code>numpy.ndarray</code>): The modified base signal with added interrupts.  </li> <li>interrupt_params (<code>list</code> of <code>dict</code>): A list of metadata describing each added interrupt, including:</li> <li><code>start_idx</code> (<code>int</code>): The start index of the interrupt.</li> <li><code>duration_idx</code> (<code>int</code>): The duration of the interrupt in samples.</li> <li><code>offset</code> (<code>float</code>): The applied amplitude offset.</li> <li><code>sinusoids_params</code> (<code>dict</code> or <code>list</code>): Parameters used to generate the sinusoidal components.</li> <li><code>type</code> (<code>str</code>):  <ul> <li><code>\"main\"</code> for the primary interrupt.  </li> <li><code>\"small\"</code> for secondary smaller interrupts.  </li> </ul> </li> </ul>"},{"location":"functions/signal/10add_interrupt_with_params/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Define a base signal (zero baseline)\nbase_signal = np.zeros_like(t)\n\n# Define device and interrupt amplitude/frequency ranges\nDEVICE_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (0.0, 5.0),\n        \"frequency\": [(5, 15), (30, 60), (70, 120)]\n    }\n}\n\nINTERRUPT_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (0.5, 2.0),\n        \"frequency\": [(5, 15), (10, 30), (20, 50)]\n    }\n}\n\n# Add a main interrupt and optionally smaller secondary interrupts\nupdated_signal, params = svg.add_interrupt_with_params(\n    t=t,\n    base_signal=base_signal,\n    domain=\"device_A\",\n    DEVICE_RANGES=DEVICE_RANGES,\n    INTERRUPT_RANGES=INTERRUPT_RANGES,\n    temp=1,\n    drop=False,\n    disperse=True,\n    duration_ratio=0.08,\n    n_smaller_interrupts=2,\n    complex_iter=1,\n    blend_factor=0.6,\n    shrink_complex=True,\n    buffer=10\n)\n\nprint(\"Updated Signal Shape:\", updated_signal.shape)\nprint(\"Interrupt Parameters:\", params)\n</code></pre>"},{"location":"functions/signal/11add_interrupt_bursts/","title":"add_interrupt_bursts","text":""},{"location":"functions/signal/11add_interrupt_bursts/#add_interrupt_bursts","title":"<code>add_interrupt_bursts</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/11add_interrupt_bursts/#description","title":"Description","text":"<p><code>add_interrupt_bursts</code> introduces multiple small sinusoidal-based interrupts into a specified time window within the signal. These interruptions mimic burst-like behavior and can be constrained to a specific range of amplitudes and frequencies. The function ensures that the added interrupts do not exceed device limitations while providing flexible placement and modification options.</p> <p>This function is useful for generating high-frequency perturbations within a defined time window, making it applicable for tasks such as synthetic signal generation, fault injection in testing environments, and simulating real-world signal bursts.</p>"},{"location":"functions/signal/11add_interrupt_bursts/#additional-notes","title":"Additional Notes","text":"<ul> <li>The function first determines a valid frequency range based on <code>DEVICE_RANGES</code> and <code>temp</code>.  </li> <li>Each interrupt is placed randomly within the specified window (<code>start_idx</code> to <code>end_idx</code>).  </li> <li>The duration of each interrupt is randomly selected within the given <code>small_duration_ratio_range</code>.  </li> <li>Interrupts may be either rising or falling, controlled by the <code>drop2</code> parameter.  </li> <li>The final signal is clipped to respect <code>device_min</code> and <code>device_max</code> constraints.  </li> </ul>"},{"location":"functions/signal/11add_interrupt_bursts/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector for the signal (usually created using <code>np.linspace</code>).  </li> <li>base_signal (<code>numpy.ndarray</code>): The original base signal that will be modified.  </li> <li>domain (<code>str</code>): The key used to retrieve amplitude and frequency ranges from <code>DEVICE_RANGES</code>.  </li> <li>DEVICE_RANGES (<code>dict</code>): Dictionary containing overall device amplitude and frequency limits.  </li> <li>device_min (<code>float</code>): The minimum allowable amplitude for the device.  </li> <li>device_max (<code>float</code>): The maximum allowable amplitude for the device.  </li> <li>temp (<code>int</code>): The index used to determine the specific frequency range from <code>DEVICE_RANGES</code>.  </li> <li>start_idx (<code>int</code>, optional): The minimum start index for bursts (default: <code>0</code>).  </li> <li>end_idx (<code>int</code>, optional): The maximum end index for bursts (default: <code>0</code>, meaning the full signal length).  </li> <li>n_small_interrupts (<code>int</code>, optional):  </li> <li>The number of small interrupts to add.  </li> <li>If <code>None</code>, a random value between <code>15</code> and <code>20</code> is chosen.  </li> <li>non_overlap (<code>bool</code>, optional):  </li> <li>If <code>True</code>, prevents interrupts from overlapping with previously placed bursts.  </li> <li>Default: <code>False</code>.  </li> <li>small_duration_ratio_range (<code>tuple</code> of <code>float</code>, optional):  </li> <li>The range of possible duration ratios for small interrupts.  </li> <li>If <code>None</code>, a random value between <code>0.001</code> and <code>0.005</code> is used.  </li> </ul>"},{"location":"functions/signal/11add_interrupt_bursts/#returns","title":"Returns","text":"<ul> <li>updated_base_signal (<code>numpy.ndarray</code>): The modified base signal with added burst-like interruptions.  </li> </ul>"},{"location":"functions/signal/11add_interrupt_bursts/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Define a base signal (zero baseline)\nbase_signal = np.zeros_like(t)\n\n# Define device amplitude and frequency limits\nDEVICE_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (0.0, 5.0),\n        \"frequency\": (70, 120)\n    }\n}\n\n# Apply multiple small bursts within a specific region of the signal\nupdated_signal = svg.add_interrupt_bursts(\n    t=t,\n    base_signal=base_signal,\n    domain=\"device_A\",\n    DEVICE_RANGES=DEVICE_RANGES,\n    device_min=0.0,\n    device_max=5.0,\n    temp=0,\n    start_idx=300,\n    end_idx=700,  # Bursts will be limited to this window\n    n_small_interrupts=10,\n    non_overlap=True,\n    small_duration_ratio_range=(0.005, 0.01)\n)\n\nprint(\"Updated Signal Shape:\", updated_signal.shape)\n</code></pre>"},{"location":"functions/signal/12generate_semi_periodic_signal/","title":"generate_semi_periodic_signal","text":""},{"location":"functions/signal/12generate_semi_periodic_signal/#generate_semi_periodic_signal","title":"<code>generate_semi_periodic_signal</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/12generate_semi_periodic_signal/#description","title":"Description","text":"<p><code>generate_semi_periodic_signal</code> creates a semi-periodic digital signal by repeating a given binary pattern and introducing random bit flips. This function is useful for modeling schedulled interruptions with possible delays.</p>"},{"location":"functions/signal/12generate_semi_periodic_signal/#notes","title":"Notes","text":"<ul> <li>Increasing <code>flip_probability</code> increases randomness, making the signal less periodic.</li> <li>The function repeats <code>base_pattern</code> as needed and truncates to the required <code>length</code>.</li> <li>Setting a <code>seed</code> ensures consistent signal generation across multiple runs.</li> </ul>"},{"location":"functions/signal/12generate_semi_periodic_signal/#parameters","title":"Parameters","text":"<ul> <li> <p>length (<code>int</code>, optional): The total length of the generated signal (default: <code>450</code>).</p> </li> <li> <p>base_pattern (<code>list</code> of <code>int</code>, optional): A binary sequence representing the repeating base pattern.  </p> </li> <li> <p>If <code>None</code>, defaults to <code>[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]</code>.</p> </li> <li> <p>flip_probability (<code>float</code>, optional): The probability of flipping each bit to simulate signal variations (default: <code>0.1</code>).</p> </li> <li> <p>seed (<code>int</code>, optional): Random seed for reproducibility (default: <code>None</code>).</p> </li> </ul>"},{"location":"functions/signal/12generate_semi_periodic_signal/#returns","title":"Returns","text":"<ul> <li>semi_periodic_signal (<code>numpy.ndarray</code>):   The generated semi-periodic binary signal.</li> </ul>"},{"location":"functions/signal/12generate_semi_periodic_signal/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Generate a semi-periodic signal with a bit flip probability of 5%\nsemi_periodic_signal = svg.generate_semi_periodic_signal(length=300, flip_probability=0.05)\n\nprint(\"Generated Signal:\", semi_periodic_signal[:20])  # Print first 20 samples\n</code></pre>"},{"location":"functions/signal/13add_periodic_interrupts/","title":"add_periodic_interrupts","text":""},{"location":"functions/signal/13add_periodic_interrupts/#add_periodic_interrupts","title":"<code>add_periodic_interrupts</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/13add_periodic_interrupts/#description","title":"Description","text":"<p><code>add_periodic_interrupts</code> introduces periodic digital interruptions into a base signal. It applies binary modulated interruptions in two distinct phases: 1. Before and after the main interruption. 2. During the main interruption.</p>"},{"location":"functions/signal/13add_periodic_interrupts/#parameters","title":"Parameters","text":"<ul> <li> <p>base_signal (<code>numpy.ndarray</code>): The original signal to which periodic interruptions will be added.</p> </li> <li> <p>amplitude_range (<code>tuple</code> of <code>float</code>): The <code>(min, max)</code> amplitude range of the device.</p> </li> <li> <p>inter_sig (<code>numpy.ndarray</code>): The interrupt signal to be modulated and inserted into the base signal.</p> </li> <li> <p>start_idx (<code>int</code>): The start index of the main interruption.</p> </li> <li> <p>duration_idx (<code>int</code>): The duration (in samples) of the main interruption.</p> </li> <li> <p>length (<code>int</code>, optional): The default length of the periodic signals if <code>base_pattern</code> is <code>None</code> (default: <code>450</code>).</p> </li> <li> <p>base_pattern, base_pattern_2 (<code>list</code> of <code>int</code>, optional): Binary sequences representing the two periodic interruption patterns.  </p> </li> <li> <p>If <code>None</code>, defaults to <code>[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]</code>.</p> </li> <li> <p>flip_probability, flip_probability_2 (<code>float</code>, optional): The probability of flipping bits in each periodic pattern (default: <code>0.1</code>).</p> </li> <li> <p>offset (<code>float</code>): The amplitude offset applied to interruptions.</p> </li> </ul>"},{"location":"functions/signal/13add_periodic_interrupts/#returns","title":"Returns","text":"<ul> <li>modified_signal (<code>numpy.ndarray</code>): The modified base signal containing periodic interruptions.</li> </ul>"},{"location":"functions/signal/13add_periodic_interrupts/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Example base signal\nbase_signal = np.ones(1000)\n\n# Example periodic interrupt waveform\ninter_sig = np.sin(np.linspace(0, np.pi, 1000))\n\n# Apply periodic interruptions\nmodified_signal = svg.add_periodic_interrupts(\n    base_signal=base_signal,\n    length=1000,\n    amplitude_range=(0, 2),\n    inter_sig=inter_sig,\n    start_idx=300,\n    duration_idx=100,\n    offset=0.5\n)\n\nprint(\"Modified Signal (First 350 Samples):\", modified_signal[:350])\n</code></pre>"},{"location":"functions/signal/1generate_signal/","title":"generate_signal","text":"<p>Location: <code>signal/signal_generation.py</code></p>"},{"location":"functions/signal/1generate_signal/#description","title":"Description","text":"<p><code>generate_signal</code> constructs a composite waveform by summing multiple sinusoidal components. Each component is assigned a random amplitude, frequency, and phase from user\u2011defined ranges. After generation, the composite signal is normalized\u2014centering it around zero mean and scaling to fit a specified amplitude interval. This approach mirrors real\u2011world signals, which often comprise numerous harmonic elements.</p>"},{"location":"functions/signal/1generate_signal/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector over which the signal is sampled.  </li> <li>n_sinusoids (<code>int</code>): The number of sinusoidal components.  </li> <li>amplitude_range (<code>tuple</code> of floats): Minimum and maximum amplitudes for each sinusoid.  </li> <li>frequency_range (<code>tuple</code> of floats): Minimum and maximum frequencies for each sinusoid.</li> </ul>"},{"location":"functions/signal/1generate_signal/#returns","title":"Returns","text":"<ul> <li>signal (<code>numpy.ndarray</code>): The composite waveform.  </li> <li>sinusoids_params (<code>list</code> of <code>dict</code>): Contains <code>amp</code>, <code>freq</code>, and <code>phase</code> for each sinusoid.</li> </ul>"},{"location":"functions/signal/1generate_signal/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Generate a composite signal made up of five sinusoidal components\nsignal, params = svg.generate_signal(\n    t,\n    n_sinusoids=5,\n    amplitude_range=(0.1, 1.0),\n    frequency_range=(24, 120)\n)\n\nprint(\"Generated signal shape:\", signal.shape)\nprint(\"Sinusoid parameters:\", params)\n</code></pre>"},{"location":"functions/signal/2get_non_overlapping_interval/","title":"get_non_overlapping_interval","text":""},{"location":"functions/signal/2get_non_overlapping_interval/#get_non_overlapping_interval","title":"<code>get_non_overlapping_interval</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/2get_non_overlapping_interval/#description","title":"Description","text":"<p><code>get_non_overlapping_interval</code> attempts to find a valid start index for an interrupt interval that does not overlap with any existing occupied intervals. The function ensures that newly placed interruptions maintain separation from existing ones, considering an optional buffer. If no suitable interval is found within the maximum number of tries, the function returns <code>None</code>.</p> <p>This function is useful for scheduling perturbations in signals where interruptions must be placed without conflicts.</p>"},{"location":"functions/signal/2get_non_overlapping_interval/#parameters","title":"Parameters","text":"<ul> <li>signal_length (<code>int</code>): The total length of the signal (in samples).  </li> <li>duration_idx (<code>int</code>): The duration of the interrupt (in samples).  </li> <li>occupied_intervals (<code>list</code> of <code>tuple</code>): List of <code>(start_idx, end_idx)</code> pairs representing already occupied intervals.  </li> <li>max_tries (<code>int</code>, optional): Maximum number of attempts to find a valid interval (default: <code>1000</code>).  </li> <li>buffer (<code>int</code>, optional): Minimum separation between interruptions (default: <code>1</code>).</li> </ul>"},{"location":"functions/signal/2get_non_overlapping_interval/#returns","title":"Returns","text":"<ul> <li><code>tuple</code> (<code>(start_idx, end_idx)</code>) if a non-overlapping interval is found.  </li> <li><code>None</code> if no valid interval is found after <code>max_tries</code>.</li> </ul>"},{"location":"functions/signal/2get_non_overlapping_interval/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\n# Define occupied intervals\noccupied_intervals = [(100, 200), (300, 400)]\n\n# Attempt to place a non-overlapping interval in a signal of length 1000\ninterval = svg.get_non_overlapping_interval(1000, duration_idx=50, occupied_intervals=occupied_intervals)\n\nprint(\"New Interval:\", interval)  # Example output: (450, 500)\n</code></pre>"},{"location":"functions/signal/3place_interrupt/","title":"place_interrupt","text":""},{"location":"functions/signal/3place_interrupt/#place_interrupt","title":"<code>place_interrupt</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/3place_interrupt/#description","title":"Description","text":"<p><code>place_interrupt</code> is a utility function that determines a valid placement for an interrupt within a signal. The interrupt duration is defined as a fraction of the total signal length. The function ensures that interruptions are placed correctly, either avoiding overlaps with existing occupied intervals (when <code>non_overlap=True</code>) or allowing random placement.</p> <p>This function is useful for scheduling perturbations in signals where controlled disruptions are required for testing, simulation, or augmentation.</p>"},{"location":"functions/signal/3place_interrupt/#parameters","title":"Parameters","text":"<ul> <li>signal_length (<code>int</code>): The total length of the signal (in samples).  </li> <li>duration_ratio (<code>float</code>): The fraction of the signal length that the interrupt should occupy.  </li> <li>occupied_intervals (<code>list</code> of <code>tuple</code>): List of <code>(start_idx, end_idx)</code> pairs representing already occupied intervals.  </li> <li>non_overlap (<code>bool</code>, optional): If <code>True</code>, ensures the interrupt does not overlap with existing intervals (default: <code>True</code>).  </li> <li>buffer (<code>int</code>, optional): Minimum separation between interruptions when <code>non_overlap=True</code> (default: <code>1</code>).</li> </ul>"},{"location":"functions/signal/3place_interrupt/#returns","title":"Returns","text":"<ul> <li><code>tuple</code> (<code>(start_idx, end_idx)</code>) if a valid placement is found.  </li> <li><code>None</code> if no valid placement is possible.</li> </ul>"},{"location":"functions/signal/3place_interrupt/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\n# Define occupied intervals\noccupied_intervals = [(100, 200), (300, 400)]\n\n# Attempt to place an interrupt in a signal of length 1000, occupying 5% of the signal\ninterrupt_interval = svg.place_interrupt(1000, duration_ratio=0.05, occupied_intervals=occupied_intervals)\n\nprint(\"Placed Interrupt:\", interrupt_interval)  # Example output: (500, 550)\n</code></pre>"},{"location":"functions/signal/4blend_signal/","title":"blend_signal","text":""},{"location":"functions/signal/4blend_signal/#blend_signal","title":"<code>blend_signal</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/4blend_signal/#description","title":"Description","text":"<p><code>blend_signal</code> combines a base signal segment with an interrupt segment using a linear blending factor. This function allows controlled integration of an interrupt into an existing signal, where the <code>blend</code> parameter determines how much of the base signal is preserved versus how much of the interrupt is applied.</p> <p>This technique is useful for smooth signal modifications, ensuring better alignment with device amplitude and frequency boundaries.</p>"},{"location":"functions/signal/4blend_signal/#parameters","title":"Parameters","text":"<ul> <li>base_slice (<code>numpy.ndarray</code>): The base signal segment to be modified.  </li> <li>interrupt_slice (<code>numpy.ndarray</code>): The interrupt signal segment to be blended into the base signal.  </li> <li>blend (<code>float</code>, optional): The blending factor between <code>0</code> and <code>1</code> (default: <code>0.5</code>).</li> <li>A value closer to <code>1</code> retains more of the base signal.</li> <li>A value closer to <code>0</code> retains more of the interrupt signal.</li> </ul>"},{"location":"functions/signal/4blend_signal/#returns","title":"Returns","text":"<ul> <li>blended_signal (<code>numpy.ndarray</code>): The resulting signal segment after blending.</li> </ul>"},{"location":"functions/signal/4blend_signal/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create example base and interrupt slices\nbase_slice = np.array([1, 2, 3, 4, 5])\ninterrupt_slice = np.array([10, 9, 8, 7, 6])\n\n# Blend the two slices with a factor of 0.7 (favoring base signal)\nblended = svg.blend_signal(base_slice, interrupt_slice, blend=0.7)\n\nprint(\"Blended Signal:\", blended)  \n# Example Output: [3.3, 3.9, 4.5, 5.1, 5.7]\n</code></pre>"},{"location":"functions/signal/5apply_interrupt_modifications/","title":"apply_interrupt_modifications","text":""},{"location":"functions/signal/5apply_interrupt_modifications/#apply_interrupt_modifications","title":"<code>apply_interrupt_modifications</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/5apply_interrupt_modifications/#description","title":"Description","text":"<p><code>apply_interrupt_modifications</code> applies amplitude shifting and optional baseline drift on the interrupt segment, and later blend it into a base signal. By controlling drift behavior (<code>disperse=True/False</code>) and specifying whether the signal should drop or rise, the function ensures that interruptions remain realistic while conforming to system limitations. Finally,it adjusts an interrupt signal segment to fit within predefined device constraints.</p>"},{"location":"functions/signal/5apply_interrupt_modifications/#parameters","title":"Parameters","text":"<ul> <li>inter_part (<code>numpy.ndarray</code>): The segment of the interrupt signal to be modified.  </li> <li>base_part (<code>numpy.ndarray</code>): The corresponding segment of the base signal.  </li> <li>device_min (<code>float</code>): Minimum allowed amplitude of the device.  </li> <li>device_max (<code>float</code>): Maximum allowed amplitude of the device.  </li> <li>drop (<code>bool</code>):  </li> <li>If <code>True</code>, shifts the interrupt signal downward (drops below baseline).  </li> <li>If <code>False</code>, shifts the interrupt signal upward.  </li> <li>disperse (<code>bool</code>, optional):  </li> <li>If <code>True</code>, applies a varying baseline drift with peak drift in the middle (default: <code>False</code>).  </li> <li>blend_factor (<code>float</code>, optional):  </li> <li>The blending factor between <code>0</code> and <code>1</code> (default: <code>0.5</code>).  </li> <li>A higher value retains more of the base signal.  </li> <li>A lower value retains more of the interrupt signal.</li> </ul>"},{"location":"functions/signal/5apply_interrupt_modifications/#returns","title":"Returns","text":"<ul> <li>modified_inter_part (<code>numpy.ndarray</code>): The modified interrupt signal segment after drift and offset adjustments.  </li> <li>offset (<code>float</code>): The amount by which the interrupt signal was shifted.</li> </ul>"},{"location":"functions/signal/5apply_interrupt_modifications/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create example base and interrupt signal segments\nbase_part = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\ninter_part = np.array([10.0, 9.5, 9.0, 8.5, 8.0])\n\n# Define device amplitude limits\ndevice_min, device_max = 0.0, 10.0\n\n# Apply modifications to the interrupt segment\nmodified_inter, offset = svg.apply_interrupt_modifications(\n    inter_part, base_part, device_min, device_max, drop=True, disperse=True, blend_factor=0.7\n)\n\nprint(\"Modified Interrupt:\", modified_inter)\nprint(\"Applied Offset:\", offset)\n</code></pre>"},{"location":"functions/signal/6generate_main_interrupt/","title":"generate_main_interrupt","text":""},{"location":"functions/signal/6generate_main_interrupt/#generate_main_interrupt","title":"<code>generate_main_interrupt</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/6generate_main_interrupt/#description","title":"Description","text":"<p><code>generate_main_interrupt</code> creates a sinusoidal-based interrupt signal by wrapping around the <code>generate_signal</code> function. The function dynamically selects frequency and amplitude ranges from a given <code>interrupt_ranges</code> dictionary. Additionally, optional scaling factors enable users to fine-tune amplitude and frequency variations. Note: Scaling factors results in prioritization of specific region of predefined range, and shouldn't be used to go beyond initial range. </p>"},{"location":"functions/signal/6generate_main_interrupt/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector for the signal (typically generated using <code>np.linspace</code>).  </li> <li>domain (<code>str</code>): The key used to access amplitude and frequency ranges from <code>interrupt_ranges</code>.  </li> <li>interrupt_ranges (<code>dict</code>): A dictionary containing predefined amplitude and frequency ranges for different domains.  </li> <li>temp (<code>int</code>): Determines which frequency index to use within the frequency range.  </li> <li>n_sinusoids (<code>int</code>, optional): Number of sinusoids to sum in the interrupt signal. If <code>None</code>, a random value between <code>2</code> and <code>10</code> is chosen.  </li> <li>amplitude_scale (<code>float</code>, optional): Scaling factor applied to amplitude values (default: <code>1.0</code>).  </li> <li>frequency_scale (<code>float</code>, optional): Scaling factor applied to frequency values (default: <code>1.0</code>).  </li> </ul>"},{"location":"functions/signal/6generate_main_interrupt/#returns","title":"Returns","text":"<ul> <li>interrupt_signal (<code>numpy.ndarray</code>): The generated interrupt signal composed of sinusoidal components.  </li> <li>interrupt_params (<code>list</code> of <code>dict</code>): A list containing dictionaries with the parameters (<code>amp</code>, <code>freq</code>, <code>phase</code>) of each generated sinusoid.  </li> </ul>"},{"location":"functions/signal/6generate_main_interrupt/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Define a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Define predefined amplitude and frequency ranges\ninterrupt_ranges = {\n    \"device_A\": {\n        \"amplitude\": (0.5, 2.0),\n        \"frequency\": [(5, 15), (30, 60), (70, 120)]  # Example frequency options\n    }\n}\n\n# Generate an interrupt signal for domain \"device_A\" using frequency index 1\ninterrupt_signal, params = svg.generate_main_interrupt(\n    t,\n    domain=\"device_A\",\n    interrupt_ranges=interrupt_ranges,\n    temp=1,  # Selects the second frequency range (10-30 Hz)\n    n_sinusoids=5,\n    amplitude_scale=1.2,\n    frequency_scale=0.9\n)\n\nprint(\"Generated Interrupt Signal Shape:\", interrupt_signal.shape)\nprint(\"Sinusoid Parameters:\", params)\n</code></pre>"},{"location":"functions/signal/7add_main_interrupt/","title":"add_main_interrupt","text":""},{"location":"functions/signal/7add_main_interrupt/#add_main_interrupt","title":"<code>add_main_interrupt</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/7add_main_interrupt/#description","title":"Description","text":"<p><code>add_main_interrupt</code> inserts a sinusoidal-based interrupt into a base signal, allowing for realistic signal perturbations. The function selects an appropriate location for the main interrupt, ensuring it fits within predefined amplitude and frequency constraints. It also supports the addition of smaller overlapping secondary interrupts when <code>complex_iter &gt; 0</code>, making it suitable for generating complex perturbation patterns. This function is useful for simulating controlled perturbating signals.</p> <p>Note: Position of the interrupt mostly identified by its initial params and blend factor with idle wave. Additionally, small offset based on the drop factor might be introduced.</p>"},{"location":"functions/signal/7add_main_interrupt/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector for the signal (typically generated using <code>np.linspace</code>).  </li> <li>base_signal (<code>numpy.ndarray</code>): The original base signal, which may already contain modifications.  </li> <li>domain (<code>str</code>): Key used to access amplitude and frequency ranges from <code>RANGES</code>.  </li> <li>DEVICE_RANGES (<code>dict</code>): A dictionary containing overall amplitude and frequency limits for the device (helps to identify device min and max).  </li> <li>INTERRUPT_RANGES (<code>dict</code>): A dictionary containing amplitude and frequency ranges for each domain.  </li> <li>temp (<code>int</code>): Index used to determine which frequency range to select.  </li> <li>duration_ratio (<code>float</code>): The fraction of the total signal length occupied by the main interrupt.  </li> <li>disperse (<code>bool</code>, optional):  </li> <li>If <code>True</code>, applies a baseline drift with a peak drift in the middle (default: <code>True</code>).  </li> <li>drop (<code>bool</code>, optional):  </li> <li>If <code>True</code>, modifies the signal to dip below the baseline instead of rising above. Impacts disperse direction. </li> <li>n_sinusoids (<code>int</code>, optional): The number of sinusoids composing the interrupt signal. If <code>None</code>, a random value between <code>2</code> and <code>10</code> is selected.  </li> <li>non_overlap (<code>bool</code>, optional):  </li> <li>If <code>True</code>, ensures that the main interrupt does not overlap with existing intervals.  </li> <li>complex_iter (<code>int</code>, optional):  </li> <li>The number of smaller overlapping interrupts to be added inside the main interrupt (default: <code>0</code>).  </li> <li>blend_factor (<code>float</code>, optional):  </li> <li>The blending weight between the base and interrupt signal (default: <code>0.5</code>).  </li> <li>shrink_complex (<code>bool</code>, optional):  </li> <li>If <code>True</code>, each successive smaller interrupt is shorter than the previous one.  </li> <li>shrink_factor (<code>float</code>, optional):  </li> <li>The fraction by which the duration of each smaller interrupt shrinks (default: <code>0.9</code>).  </li> </ul>"},{"location":"functions/signal/7add_main_interrupt/#returns","title":"Returns","text":"<ul> <li>updated_base_signal (<code>numpy.ndarray</code>): The modified base signal after adding the main and optional complex interrupts.  </li> <li>interrupt_params (<code>list</code> of <code>dict</code>): Metadata describing the added interrupts, including:</li> <li><code>start_idx</code> (<code>int</code>): The start index of the interrupt.</li> <li><code>duration_idx</code> (<code>int</code>): The duration of the interrupt in samples.</li> <li><code>offset</code> (<code>float</code>): The applied amplitude offset.</li> <li><code>sinusoids_params</code> (<code>dict</code>): Parameters used to generate the sinusoids.</li> <li><code>type</code> (<code>str</code>): <code>\"main\"</code> for the primary interrupt, <code>\"complex\"</code> for secondary overlapping interrupts.</li> <li>occupied_intervals (<code>list</code> of <code>tuple</code>): Updated list of <code>(start_idx, end_idx)</code> intervals representing occupied regions in the signal.</li> </ul>"},{"location":"functions/signal/7add_main_interrupt/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Define a base signal\nbase_signal = np.zeros_like(t)\n\n# Define device and interrupt amplitude/frequency ranges\nDEVICE_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (0.0, 5.0),\n        \"frequency\": [(5, 15), (30, 60), (70, 120)]\n    }\n}\n\nINTERRUPT_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (4.0, 5.5),\n        \"frequency\": [(15, 25), (40, 70), (80, 130)]\n    }\n}\n\n# Add a main interrupt with optional complexity\nupdated_signal, params, occupied_intervals = svg.add_main_interrupt(\n    t=t,\n    base_signal=base_signal,\n    domain=\"device_A\",\n    DEVICE_RANGES=DEVICE_RANGES,\n    INTERRUPT_RANGES=INTERRUPT_RANGES,\n    temp=1,\n    duration_ratio=0.1,\n    complex_iter=2,\n    blend_factor=0.6,\n    shrink_complex=True\n)\n\nprint(\"Updated Signal Shape:\", updated_signal.shape)\nprint(\"Interrupt Parameters:\", params)\nprint(\"Occupied Intervals:\", occupied_intervals)\n</code></pre>"},{"location":"functions/signal/8add_complexity_to_inter/","title":"8add complexity to inter","text":""},{"location":"functions/signal/8add_complexity_to_inter/#add_complexity_to_inter","title":"<code>add_complexity_to_inter</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/8add_complexity_to_inter/#description","title":"Description","text":"<p><code>add_complexity_to_inter</code> introduces an overlapping (secondary) interrupt within an existing main interrupt region. This function selects a portion of the <code>full_interrupt_signal</code>, applies optional modifications such as amplitude drift and offset adjustments, and blends it into the <code>base_signal</code>. The added complexity simulates realistic signal variations, making it useful for applications where multiple overlapping perturbations are expected.</p> <p>This function is designed to be called within <code>add_main_interrupt</code> when <code>complex_iter &gt; 0</code>, ensuring multiple layers of interruptions within a base signal.</p>"},{"location":"functions/signal/8add_complexity_to_inter/#parameters","title":"Parameters","text":"<ul> <li>base_signal (<code>numpy.ndarray</code>): The full base signal, which may already contain the main interrupt.  </li> <li>full_interrupt_signal (<code>numpy.ndarray</code>): The full-length interrupt signal from which a portion is extracted.  </li> <li>start_main (<code>int</code>): The start index of the main interrupt.  </li> <li>end_main (<code>int</code>): The end index of the main interrupt.  </li> <li>domain (<code>str</code>): The key used to access amplitude and frequency ranges in <code>INTERRUPT_RANGES</code>.  </li> <li>DEVICE_RANGES (<code>dict</code>): A dictionary containing overall amplitude and frequency limits for the device.  </li> <li>INTERRUPT_RANGES (<code>dict</code>): A dictionary containing predefined amplitude and frequency ranges for each domain.  </li> <li>drop (<code>bool</code>):  </li> <li>If <code>True</code>, the interrupt offset is adjusted downward.  </li> <li>If <code>False</code>, the interrupt offset is adjusted upward.  </li> <li>old_offset (<code>float</code>): The offset applied to the main interrupt, which can be used for reference in secondary modifications.  </li> <li>sinusoids_params (<code>dict</code> or <code>list</code>): Metadata describing how the main interrupt was generated.  </li> <li>blend_factor (<code>float</code>, optional):  </li> <li>The blending weight between the base and interrupt signal (default: <code>0.5</code>).  </li> </ul>"},{"location":"functions/signal/8add_complexity_to_inter/#returns","title":"Returns","text":"<ul> <li>updated_base_signal (<code>numpy.ndarray</code>): The modified base signal after adding the overlapping interrupt.  </li> <li>interrupt_params (<code>dict</code>): Metadata describing the added secondary interrupt, including:</li> <li><code>start_idx</code> (<code>int</code>): The start index of the overlapping interrupt.</li> <li><code>duration_idx</code> (<code>int</code>): The duration of the interrupt in samples.</li> <li><code>offset</code> (<code>float</code>): The applied amplitude offset.</li> <li><code>sinusoids_params</code> (<code>dict</code> or <code>list</code>): Parameters used to generate the secondary interrupt.</li> <li><code>type</code> (<code>str</code>): <code>\"main_overlapping\"</code> to indicate a secondary interrupt within the main one.</li> </ul>"},{"location":"functions/signal/9add_smaller_interrupts/","title":"add_smaller_interrupts","text":""},{"location":"functions/signal/9add_smaller_interrupts/#add_smaller_interrupts","title":"<code>add_smaller_interrupts</code>","text":"<p>Location: <code>signal/response_signals.py</code></p>"},{"location":"functions/signal/9add_smaller_interrupts/#description","title":"Description","text":"<p><code>add_smaller_interrupts</code> inserts multiple secondary (smaller) sinusoidal-based interrupts into an existing base signal. These interrupts are placed at randomly determined positions, ensuring they do not overlap with previously occupied intervals (if <code>non_overlap=True</code>). The function applies optional modifications such as amplitude drift, baseline shifts, and controlled blending with the base signal.</p> <p>This function is useful for creating complex, realistic perturbations in synthetic signals, mimicking naturally occurring variations.</p>"},{"location":"functions/signal/9add_smaller_interrupts/#parameters","title":"Parameters","text":"<ul> <li>t (<code>numpy.ndarray</code>): The time vector for the signal (usually created using <code>np.linspace</code>).  </li> <li>base_signal (<code>numpy.ndarray</code>): The original base signal, which may already contain modifications.  </li> <li>INTERRUPT_RANGES (<code>dict</code>): Dictionary containing predefined amplitude and frequency ranges for different domains.  </li> <li>domain (<code>str</code>): The key used to retrieve amplitude and frequency ranges from <code>INTERRUPT_RANGES</code>.  </li> <li>temp (<code>int</code>): The index determining which frequency range to use.  </li> <li>n_smaller_interrupts (<code>int</code>): The number of smaller interrupts to insert into the base signal.  </li> <li>occupied_intervals (<code>list</code> of <code>tuple</code>): List of previously occupied <code>(start_idx, end_idx)</code> intervals to avoid overlap.  </li> <li>disperse (<code>bool</code>):  </li> <li>If <code>True</code>, applies a varying baseline drift with a peak drift in the middle.  </li> <li>drop (<code>bool</code>):  </li> <li>If <code>True</code>, shifts the interrupt downward (below the baseline).  </li> <li>If <code>False</code>, shifts the interrupt upward (above the baseline).  </li> <li>small_duration_ratio (<code>float</code>): The fraction of the total signal length occupied by each small interrupt.  </li> <li>n_sinusoids (<code>int</code>, optional): The number of sinusoids in each interrupt. If <code>None</code>, a random number between <code>2</code> and <code>10</code> is chosen.  </li> <li>non_overlap (<code>bool</code>, optional):  </li> <li>If <code>True</code>, ensures smaller interrupts do not overlap with existing intervals.  </li> <li>buffer (<code>int</code>, optional): The minimum number of samples to separate consecutive interrupts when <code>non_overlap=True</code> (default: <code>1</code>).</li> </ul>"},{"location":"functions/signal/9add_smaller_interrupts/#returns","title":"Returns","text":"<ul> <li>updated_base_signal (<code>numpy.ndarray</code>): The modified base signal after adding smaller interrupts.  </li> <li>interrupt_params (<code>list</code> of <code>dict</code>): Metadata for each added smaller interrupt, including:</li> <li><code>start_idx</code> (<code>int</code>): Start index of the interrupt.</li> <li><code>duration_idx</code> (<code>int</code>): Length of the interrupt in samples.</li> <li><code>offset</code> (<code>float</code>): Applied amplitude offset.</li> <li><code>sinusoids_params</code> (<code>dict</code> or <code>list</code>): Parameters used to generate the sinusoidal components.</li> <li><code>type</code> (<code>str</code>): <code>\"small\"</code> indicating a secondary interrupt.</li> </ul>"},{"location":"functions/signal/9add_smaller_interrupts/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Create a time vector from 0 to 1 second with 1000 samples\nt = np.linspace(0, 1, 1000)\n\n# Define a base signal (zero baseline)\nbase_signal = np.zeros_like(t)\n\n# Define predefined amplitude and frequency ranges\nINTERRUPT_RANGES = {\n    \"device_A\": {\n        \"amplitude\": (0.5, 2.0),\n        \"frequency\": [(5, 15), (30, 60), (70, 120)]\n    }\n}\n\n# Define occupied intervals (to prevent overlap)\noccupied_intervals = [(200, 300), (600, 700)]  # Example preoccupied regions\n\n# Add 3 smaller interrupts to the signal\nupdated_signal, params = svg.add_smaller_interrupts(\n    t=t,\n    base_signal=base_signal,\n    INTERRUPT_RANGES=INTERRUPT_RANGES,\n    domain=\"device_A\",\n    temp=1,\n    n_smaller_interrupts=3,\n    occupied_intervals=occupied_intervals,\n    disperse=True,\n    drop=False,\n    small_duration_ratio=0.05,  # Each interrupt is 5% of the total signal length\n    buffer=10  # Ensure a gap of at least 10 samples between interrupts\n)\n\nprint(\"Updated Signal Shape:\", updated_signal.shape)\nprint(\"Interrupt Parameters:\", params)\n</code></pre>"},{"location":"functions/variations/10transform_wave_with_score/","title":"transform_wave_with_score","text":""},{"location":"functions/variations/10transform_wave_with_score/#transform_wave_with_score","title":"<code>transform_wave_with_score</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/10transform_wave_with_score/#description","title":"Description","text":"<p><code>transform_wave_with_score</code> replaces segments of a waveform with newly generated signal portions based on a score-controlled probability. This function is useful for simulating signal corruption, feature substitution, or change in activity through different measurements.</p>"},{"location":"functions/variations/10transform_wave_with_score/#notes","title":"Notes","text":"<ul> <li>The function generates a replacement signal using <code>generate_signal()</code>.  </li> <li>The number and size of replacement segments depend on the <code>score</code> value.  </li> <li>Substitution is avoided within predefined interrupt regions, ensuring that important waveform segments remain intact.</li> </ul>"},{"location":"functions/variations/10transform_wave_with_score/#parameters","title":"Parameters","text":"<ul> <li> <p>original_wave (<code>numpy.ndarray</code>):   The input waveform.</p> </li> <li> <p>score (<code>float</code>):   A factor controlling how much of the waveform is transformed.  </p> </li> <li>Higher values \u2192 More segments replaced.  </li> <li> <p>Lower values \u2192 Less transformation.</p> </li> <li> <p>t (<code>numpy.ndarray</code>):   Time vector for generating the replacement signal.</p> </li> <li> <p>n_sinusoids (<code>int</code>):   Number of sinusoids in the generated replacement signal.</p> </li> <li> <p>amplitude_range (<code>tuple</code> of <code>float</code>):   Amplitude range for the replacement signal.</p> </li> <li> <p>base_frequency_range (<code>tuple</code> of <code>float</code>):   Frequency range for the replacement signal.</p> </li> <li> <p>interrupt_params (<code>list</code> of <code>dict</code>):   List of dictionaries defining interrupt regions that should not be replaced.   Example: <code>[{'start_idx': 100, 'duration_idx': 50}]</code>.</p> </li> </ul>"},{"location":"functions/variations/10transform_wave_with_score/#returns","title":"Returns","text":"<ul> <li>transformed_wave (<code>numpy.ndarray</code>):   The modified waveform with score-based segment replacement.</li> </ul>"},{"location":"functions/variations/10transform_wave_with_score/#usage-example","title":"Usage Example","text":"<pre><code>transformed_wave = svg.transform_wave_with_score(\n    wave, 0.5, t, n_sinusoids=10, \n    amplitude_range=(0,1), base_frequency_range=(70, 75), \n    interrupt_params=[{'start_idx': 200, 'duration_idx': 50}]\n)\n</code></pre>"},{"location":"functions/variations/11apply_quantization_noise/","title":"apply_quantization_noise","text":""},{"location":"functions/variations/11apply_quantization_noise/#apply_quantization_noise","title":"<code>apply_quantization_noise</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/11apply_quantization_noise/#description","title":"Description","text":"<p><code>apply_quantization_noise</code> simulates quantization effects that occur when a continuous signal is converted into a digitized form. This function reduces the bit depth of a waveform, introducing quantization noise, which is commonly encountered in low-resolution ADCs (Analog-to-Digital Converters).</p>"},{"location":"functions/variations/11apply_quantization_noise/#notes","title":"Notes","text":"<ul> <li>Lower <code>num_bits</code> results in more quantization noise, reducing signal fidelity.  </li> <li>The function scales and rounds the waveform based on the number of quantization levels.  </li> </ul>"},{"location":"functions/variations/11apply_quantization_noise/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform to be quantized.</p> </li> <li> <p>num_bits (<code>int</code>):   Number of bits for quantization.  </p> </li> <li>Higher values (e.g., <code>16-bit, 24-bit</code>) \u2192 Less noise, better resolution.  </li> <li>Lower values (e.g., <code>4-bit, 8-bit</code>) \u2192 More distortion, reduced accuracy.</li> </ul>"},{"location":"functions/variations/11apply_quantization_noise/#returns","title":"Returns","text":"<ul> <li>quantized_wave (<code>numpy.ndarray</code>):   The digitally quantized version of the input waveform.</li> </ul>"},{"location":"functions/variations/11apply_quantization_noise/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\n# Generate a sine wave and apply 8-bit quantization\nquantized_wave = svg.apply_quantization_noise(wave, num_bits=2)\n</code></pre>"},{"location":"functions/variations/1generate_parameter_variations/","title":"generate_parameter_variations","text":""},{"location":"functions/variations/1generate_parameter_variations/#generate_parameter_variations","title":"<code>generate_parameter_variations</code>","text":"<p>Location: <code>variations/variations.py</code></p>"},{"location":"functions/variations/1generate_parameter_variations/#description","title":"Description","text":"<p><code>generate_parameter_variations</code> creates randomized parameter sets to produce multiple signal variants. By selecting subranges of parameter values around randomly chosen center points, the function introduces systematic yet stochastic variability, simulating real-world signal inconsistencies.</p> <p>This function is useful for parameter space exploration, enabling controlled data augmentation for testing signal processing algorithms, improving machine learning model robustness, and simulating measurement variability in synthetic datasets.</p>"},{"location":"functions/variations/1generate_parameter_variations/#notes","title":"Notes","text":"<ul> <li>Each parameter's values are sampled from a randomly chosen subrange within the provided range (<code>param_sweeps</code>).</li> <li>The function supports multiple signal variants, ensuring diverse augmentations.</li> <li>Includes randomized frequency bounds (<code>f_min</code>, <code>f_max</code>) to introduce local modifications.</li> <li>The <code>wave_with_score</code> parameter allows integration with the <code>transform_wave_with_score</code> function, enabling controlled waveform substitution.</li> </ul>"},{"location":"functions/variations/1generate_parameter_variations/#parameters","title":"Parameters","text":"<ul> <li> <p>param_sweeps (<code>dict</code>):   Dictionary where keys represent parameter names, and values are arrays of possible values to select from.</p> </li> <li> <p>num_variants (<code>int</code>, optional):   Number of unique parameter sets to generate. Default: <code>5</code>.</p> </li> <li> <p>window_size (<code>int</code>, optional):   Half-width of the subrange selected around a center point for each parameter. Default: <code>1</code>.</p> </li> </ul>"},{"location":"functions/variations/1generate_parameter_variations/#returns","title":"Returns","text":"<ul> <li>variations (<code>list</code> of <code>dict</code>):   A list where each entry is a dictionary containing randomized parameter selections for one signal variant.</li> </ul>"},{"location":"functions/variations/1generate_parameter_variations/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Define parameter sweep ranges\nparam_sweeps = {\n    \"amplitude_range\": np.linspace(0.1, 1.0, 10),\n    \"frequency_range\": np.linspace(10, 100, 10),\n    \"modulation_depth\": np.linspace(0.2, 0.8, 5),\n}\n\n# Generate 3 parameter variations with a window size of 2\nparameter_sets = svg.generate_parameter_variations(param_sweeps, num_variants=3, window_size=2)\n\nfor i, params in enumerate(parameter_sets):\n    print(f\"Variant {i+1}: {params}\")\n</code></pre>"},{"location":"functions/variations/2generate_variation/","title":"generate_variation","text":""},{"location":"functions/variations/2generate_variation/#generate_variation","title":"<code>generate_variation</code>","text":"<p>Location: <code>variations/variations.py</code> </p>"},{"location":"functions/variations/2generate_variation/#description","title":"Description","text":"<p><code>generate_variation</code> applies a sequence of transformations to a given waveform based on variant-specific parameters. This function enables systematic signal augmentation by introducing time shifts, time warping, amplitude modifications, and baseline drift, simulating realistic signal variations observed in biomedical signals, environmental measurements, and synthetic datasets.  </p> <p>The function allows for controlled distortions by substituting segments of the signal, modifying timing characteristics, and adjusting amplitude properties.</p>"},{"location":"functions/variations/2generate_variation/#notes","title":"Notes","text":"<ul> <li>The function modifies the waveform incrementally, applying each transformation in sequence.</li> <li>Waveform substitution (<code>wave_with_score</code>) enables partial signal replacement.</li> <li>Time-warping and time-shifting introduce timing irregularities, mimicking delays and non-uniform temporal distortions.</li> <li>Amplitude modifications (gain variation and modulation) adjust signal intensity to reflect sensor inconsistencies or environmental factors.</li> <li>Baseline drift transformations simulate slow signal shifts due to sensor degradation or environmental drift.</li> </ul>"},{"location":"functions/variations/2generate_variation/#parameters","title":"Parameters","text":"<ul> <li> <p>transformed_wave (<code>numpy.ndarray</code>):   The waveform to be modified.</p> </li> <li> <p>variant_params (<code>dict</code>):   A dictionary containing transformation parameters. Expected keys: <code>'time_shift'</code> \u2192 Amount of time shift applied. <code>'time_warp'</code> \u2192 Factor for non-linear time distortion. <code>'gain_variation'</code> \u2192 Multiplicative factor for global amplitude scaling. <code>'amplitude_modulation'</code> \u2192 Strength of sinusoidal amplitude variation. <code>'modulation_with_region'</code> \u2192 Localized amplitude modulation within a signal segment. <code>'baseline_drift'</code> \u2192 Global baseline drift factor. <code>'baseline_drift_region'</code> \u2192 Localized baseline drift applied within a fraction of the signal. <code>'f_min'</code>, <code>'f_max'</code> \u2192 Start and end fractions defining localized transformations. <code>'wave_with_score'</code> \u2192 Probability score for waveform substitution.  </p> </li> <li> <p>t (<code>numpy.ndarray</code>):   Time vector for the waveform.</p> </li> <li> <p>n_sinusoids (<code>int</code>):   Number of sinusoids in the replacement signal (used when <code>wave_with_score</code> is applied).</p> </li> <li> <p>amplitude_range (<code>tuple</code> of <code>float</code>):   Range for generating new waveform segments when replacing parts of the signal.</p> </li> <li> <p>base_frequency_range (<code>tuple</code> of <code>float</code>):   Frequency range for generating replacement signal segments.</p> </li> <li> <p>interrupt_params (<code>list</code> of <code>dict</code>):   List of regions defining interrupt locations in the signal, so wave with score will not substitute it.   Example: <code>[{'start_idx': 100, 'duration_idx': 50}]</code></p> </li> </ul>"},{"location":"functions/variations/2generate_variation/#returns","title":"Returns","text":"<ul> <li>transformed_wave (<code>numpy.ndarray</code>):   The modified waveform after applying all transformations.</li> </ul>"},{"location":"functions/variations/2generate_variation/#usage-example","title":"Usage Example","text":"<pre><code>import numpy as np\nimport SigVarGen as svg\n\n# Generate a synthetic signal\nt = np.linspace(0, 1, 1000)\nwave = np.sin(2 * np.pi * 5 * t)\ninter_params = [{'start_idx': 0, 'duration_idx': 0}]\n\n# Define variation parameters\nvariant_params = {\n    \"time_shift\": 20,\n    \"time_warp\": 0.05,\n    \"gain_variation\": 1.2,\n    \"amplitude_modulation\": 0.4,\n    \"modulation_with_region\": 0.3,\n    \"baseline_drift\": 0.2,\n    \"baseline_drift_region\": 0.15,\n    \"f_min\": 0.1,\n    \"f_max\": 0.8,\n    \"wave_with_score\": 0.5\n}\n\n# Generate a signal variation\nmodified_wave = svg.generate_variation(\n    wave, variant_params, t, 5, (0.1, 1.0), (10, 100), inter_params\n)\n\nprint(\"Transformed Waveform Shape:\", modified_wave.shape)\n</code></pre>"},{"location":"functions/variations/3apply_time_shift/","title":"apply_time_shift","text":""},{"location":"functions/variations/3apply_time_shift/#apply_time_shift","title":"<code>apply_time_shift</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/3apply_time_shift/#description","title":"Description","text":"<p><code>apply_time_shift</code> introduces a random shift in a waveform by circularly shifting the signal within a given range. This transformation is useful for simulating sensor delays, synchronization errors, or minor misalignments in signal acquisition.</p>"},{"location":"functions/variations/3apply_time_shift/#notes","title":"Notes","text":"<ul> <li>The waveform is shifted by a random number of samples within the range <code>[-max_shift, max_shift]</code>.  </li> <li>Uses circular shifting, meaning values that shift beyond the end of the array wrap around to the beginning.  </li> </ul>"},{"location":"functions/variations/3apply_time_shift/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform to be shifted.</p> </li> <li> <p>max_shift (<code>int</code>):   The maximum number of samples to shift in either direction.</p> </li> </ul>"},{"location":"functions/variations/3apply_time_shift/#returns","title":"Returns","text":"<ul> <li>shifted_wave (<code>numpy.ndarray</code>):   The time-shifted waveform.</li> </ul>"},{"location":"functions/variations/3apply_time_shift/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\nshifted_wave = svg.apply_time_shift(wave, max_shift=50)\n</code></pre>"},{"location":"functions/variations/4apply_time_warp/","title":"apply_time_warp","text":""},{"location":"functions/variations/4apply_time_warp/#apply_time_warp","title":"<code>apply_time_warp</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/4apply_time_warp/#description","title":"Description","text":"<p><code>apply_time_warp</code> modifies the time axis of a signal, compressing or expanding sections to create nonlinear distortions. This function is useful for modeling variable-speed processes, signal stretching, or real-world timing irregularities.</p>"},{"location":"functions/variations/4apply_time_warp/#notes","title":"Notes","text":"<ul> <li>The time axis is scaled by a random factor in the range <code>[1 - max_warp_factor, 1 + max_warp_factor]</code>.  </li> <li>Missing parts introduced by warping are replaced using a newly generated signal segment, ensuring smooth continuity.  </li> </ul>"},{"location":"functions/variations/4apply_time_warp/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform to be warped.</p> </li> <li> <p>max_warp_factor (<code>float</code>):   The maximum factor for time warping (values close to <code>1</code> result in minimal warping).</p> </li> <li> <p>t (<code>numpy.ndarray</code>):   Time vector of the signal.</p> </li> <li> <p>n_sinusoids (<code>int</code>):   Number of sinusoids in the generated replacement signal.</p> </li> <li> <p>amplitude_range (<code>tuple</code> of <code>float</code>):   Amplitude range for the replacement signal.</p> </li> <li> <p>base_frequency_range (<code>tuple</code> of <code>float</code>):   Frequency range for the replacement signal.</p> </li> </ul>"},{"location":"functions/variations/4apply_time_warp/#returns","title":"Returns","text":"<ul> <li>warped_wave (<code>numpy.ndarray</code>):   The time-warped waveform.</li> </ul>"},{"location":"functions/variations/4apply_time_warp/#usage-example","title":"Usage Example","text":"<pre><code>warped_wave = svg.apply_time_warp(wave, 0.1, t, 5, (0.1, 1.0), (10, 100))\n</code></pre>"},{"location":"functions/variations/5apply_gain_variation/","title":"apply_gain_variation","text":""},{"location":"functions/variations/5apply_gain_variation/#apply_gain_variation","title":"<code>apply_gain_variation</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/5apply_gain_variation/#description","title":"Description","text":"<p><code>apply_gain_variation</code> randomly scales the amplitude of a signal by applying a multiplicative gain factor. This transformation simulates changes in sensor sensitivity, varying signal strengths, or environmental gain fluctuations.</p>"},{"location":"functions/variations/5apply_gain_variation/#notes","title":"Notes","text":"<ul> <li>The gain factor is selected randomly in the range <code>[1 - max_gain_variation, 1 + max_gain_variation]</code>.  </li> <li>The waveform shape remains unchanged, only the amplitude is affected.  </li> </ul>"},{"location":"functions/variations/5apply_gain_variation/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform.</p> </li> <li> <p>max_gain_variation (<code>float</code>):   The maximum deviation in gain factor.</p> </li> </ul>"},{"location":"functions/variations/5apply_gain_variation/#returns","title":"Returns","text":"<ul> <li>modified_wave (<code>numpy.ndarray</code>):   The gain-modified waveform.</li> </ul>"},{"location":"functions/variations/5apply_gain_variation/#usage-example","title":"Usage Example","text":"<pre><code>modified_wave = svg.apply_gain_variation(wave, max_gain_variation=0.2)\n</code></pre>"},{"location":"functions/variations/6apply_amplitude_modulation/","title":"apply_amplitude_modulation","text":""},{"location":"functions/variations/6apply_amplitude_modulation/#apply_amplitude_modulation","title":"<code>apply_amplitude_modulation</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/6apply_amplitude_modulation/#description","title":"Description","text":"<p><code>apply_amplitude_modulation</code> introduces periodic variations in a waveform's amplitude using sinusoidal modulation. This transformation simulates oscillatory changes in signal intensity, such as fading, interference, or natural rhythmic fluctuations.</p>"},{"location":"functions/variations/6apply_amplitude_modulation/#notes","title":"Notes","text":"<ul> <li>The modulation depth controls the strength of the amplitude variations.  </li> <li>Uses a random modulation frequency within <code>[0.1, 1.0] Hz</code>.  </li> <li>The original signal is preserved, with only its amplitude varying over time.  </li> </ul>"},{"location":"functions/variations/6apply_amplitude_modulation/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform.</p> </li> <li> <p>modulation_depth (<code>float</code>):   Strength of amplitude modulation.</p> </li> </ul>"},{"location":"functions/variations/6apply_amplitude_modulation/#returns","title":"Returns","text":"<ul> <li>modulated_wave (<code>numpy.ndarray</code>):   The amplitude-modulated waveform.</li> </ul>"},{"location":"functions/variations/6apply_amplitude_modulation/#usage-example","title":"Usage Example","text":"<pre><code>modulated_wave = svg.apply_amplitude_modulation(wave, 0.5)\n</code></pre>"},{"location":"functions/variations/7apply_amplitude_modulation_region/","title":"apply_amplitude_modulation_region","text":""},{"location":"functions/variations/7apply_amplitude_modulation_region/#apply_amplitude_modulation_region","title":"<code>apply_amplitude_modulation_region</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/7apply_amplitude_modulation_region/#description","title":"Description","text":"<p><code>apply_amplitude_modulation_region</code> applies localized amplitude modulation to a specific portion of a signal. This is useful for simulating partial signal fluctuations, such as localized interference or dynamic system responses.</p>"},{"location":"functions/variations/7apply_amplitude_modulation_region/#notes","title":"Notes","text":"<ul> <li>Modulation occurs only within the specified fraction (<code>f_min</code> to <code>f_max</code>) of the signal length.  </li> <li>Uses sinusoidal modulation with a random frequency between <code>0.1 Hz</code> and <code>1.0 Hz</code>.  </li> <li>The rest of the waveform remains unchanged.</li> </ul>"},{"location":"functions/variations/7apply_amplitude_modulation_region/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform.</p> </li> <li> <p>modulation_depth (<code>float</code>, optional):   Strength of the amplitude modulation. Default: <code>0.5</code>.</p> </li> <li> <p>f_min (<code>float</code>, optional):   Fraction of the signal length where modulation starts. Default: <code>0.1</code>.</p> </li> <li> <p>f_max (<code>float</code>, optional):   Fraction of the signal length where modulation stops. Default: <code>1.0</code>.</p> </li> </ul>"},{"location":"functions/variations/7apply_amplitude_modulation_region/#returns","title":"Returns","text":"<ul> <li>modulated_wave (<code>numpy.ndarray</code>):   The waveform with localized amplitude modulation.</li> </ul>"},{"location":"functions/variations/7apply_amplitude_modulation_region/#usage-example","title":"Usage Example","text":"<pre><code>modulated_wave = svg.apply_amplitude_modulation_region(wave, 0.3, 0.2, 0.8)\n</code></pre>"},{"location":"functions/variations/8apply_baseline_drift/","title":"apply_baseline_drift","text":""},{"location":"functions/variations/8apply_baseline_drift/#apply_baseline_drift","title":"<code>apply_baseline_drift</code>","text":"<p>Location: <code>variations/transformations.py</code></p>"},{"location":"functions/variations/8apply_baseline_drift/#description","title":"Description","text":"<p><code>apply_baseline_drift</code> introduces a linear shift in a signal\u2019s baseline, simulating gradual sensor drift, environmental changes, or instrument degradation. The drift can increase or decrease over time, depending on the selected parameters.</p>"},{"location":"functions/variations/8apply_baseline_drift/#notes","title":"Notes","text":"<ul> <li>The maximum drift amplitude is randomly chosen within the range <code>[-max_drift, max_drift]</code>.  </li> <li>If <code>reversed=True</code>, the drift starts at its peak and returns to zero.  </li> <li>When <code>reversed=False</code>, the drift gradually increases from zero.</li> </ul>"},{"location":"functions/variations/8apply_baseline_drift/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input waveform.</p> </li> <li> <p>max_drift (<code>float</code>):   The maximum drift applied to the signal\u2019s baseline.</p> </li> <li> <p>reversed (<code>bool</code>, optional):   If <code>True</code>, the drift starts at its maximum and reduces to zero. Default: <code>False</code>.</p> </li> </ul>"},{"location":"functions/variations/8apply_baseline_drift/#returns","title":"Returns","text":"<ul> <li>drifted_wave (<code>numpy.ndarray</code>):   The waveform with the applied baseline drift.</li> </ul>"},{"location":"functions/variations/8apply_baseline_drift/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\ndrifted_wave = svg.apply_baseline_drift(wave, 0.1, reversed=True)\n</code></pre>"},{"location":"functions/variations/9regional_baseline_drifts/","title":"Regional baseline drifts","text":"<p>These functions introduce different baseline drift behaviors, allowing for localized  piecewise, polynomial, or middle-peak drifts. </p>"},{"location":"functions/variations/9regional_baseline_drifts/#apply_baseline_drift_region","title":"<code>apply_baseline_drift_region</code>","text":"<p>Location: <code>variations/baseline_drift.py</code></p>"},{"location":"functions/variations/9regional_baseline_drifts/#description","title":"Description","text":"<p><code>apply_baseline_drift_region</code> introduces localized baseline drift in a specific segment of a waveform.</p>"},{"location":"functions/variations/9regional_baseline_drifts/#notes","title":"Notes","text":"<ul> <li>Drift is applied only within a selected fraction of the signal, defined by <code>start_frac</code> and <code>end_frac</code>.  </li> <li>Outside this region, the original waveform remains unchanged.  </li> <li>Uses linear interpolation for smooth transition within the drift region.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#parameters","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input signal.</p> </li> <li> <p>max_drift (<code>float</code>):   Maximum amplitude of the drift.</p> </li> <li> <p>start_frac (<code>float</code>, optional):   Fractional position where the drift starts (<code>0.3</code> = 30% into the signal). Default: <code>0.3</code>.</p> </li> <li> <p>end_frac (<code>float</code>, optional):   Fractional position where the drift ends (<code>0.7</code> = 70% into the signal). Default: <code>0.7</code>.</p> </li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#returns","title":"Returns","text":"<ul> <li>drifted_wave (<code>numpy.ndarray</code>):   The waveform with localized baseline drift.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#usage-example","title":"Usage Example","text":"<pre><code>import SigVarGen as svg\n\ndrifted_wave = svg.apply_baseline_drift_region(wave, max_drift=0.2, start_frac=0.4, end_frac=0.8)\n</code></pre>"},{"location":"functions/variations/9regional_baseline_drifts/#apply_baseline_drift_polynomial","title":"<code>apply_baseline_drift_polynomial</code>","text":"<p>Location: <code>variations/baseline_drift.py</code></p>"},{"location":"functions/variations/9regional_baseline_drifts/#description_1","title":"Description","text":"<p><code>apply_baseline_drift_polynomial</code> introduces a smooth, polynomial drift across an entire signal. The drift gradually increases or decreases, making it ideal for modeling slow environmental changes, power fluctuations, or long-term sensor drift.</p>"},{"location":"functions/variations/9regional_baseline_drifts/#notes_1","title":"Notes","text":"<ul> <li>Uses polynomial scaling (<code>order=2</code> by default, quadratic drift).  </li> <li>The drift can be reversed, causing it to start at the peak and return to zero.  </li> <li>A higher-order polynomial (e.g., <code>order=3</code>) introduces nonlinear drift effects.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#parameters_1","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input signal.</p> </li> <li> <p>max_drift (<code>float</code>):   Maximum amplitude of the drift.</p> </li> <li> <p>reversed (<code>bool</code>, optional):   If <code>True</code>, the drift starts at its peak and decreases. Default: <code>False</code>.</p> </li> <li> <p>order (<code>int</code>, optional):   Polynomial order of the drift. Default: <code>2</code> (quadratic).</p> </li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#returns_1","title":"Returns","text":"<ul> <li>drifted_wave (<code>numpy.ndarray</code>):   The waveform with a polynomial baseline drift.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#usage-example_1","title":"Usage Example","text":"<pre><code>drifted_wave = svg.apply_baseline_drift_polynomial(wave, max_drift=0.3, order=3)\n</code></pre>"},{"location":"functions/variations/9regional_baseline_drifts/#apply_baseline_drift_piecewise","title":"<code>apply_baseline_drift_piecewise</code>","text":"<p>Location: <code>variations/baseline_drift.py</code></p>"},{"location":"functions/variations/9regional_baseline_drifts/#description_2","title":"Description","text":"<p><code>apply_baseline_drift_piecewise</code> introduces stepwise drift changes, where different sections of the waveform have randomly varying baseline shifts.</p>"},{"location":"functions/variations/9regional_baseline_drifts/#notes_2","title":"Notes","text":"<ul> <li>Divides the waveform into multiple segments, each with an independent drift value.  </li> <li>The drift values can be reversed, starting from the maximum and decreasing.  </li> <li>The number of segments is controlled by <code>num_pieces</code>, with each piece having a unique baseline level.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#parameters_2","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input signal.</p> </li> <li> <p>max_drift (<code>float</code>):   Maximum amplitude of drift per segment.</p> </li> <li> <p>reversed (<code>bool</code>, optional):   If <code>True</code>, the drift starts at its highest and gradually decreases. Default: <code>False</code>.</p> </li> <li> <p>num_pieces (<code>int</code>, optional):   Number of segments for the drift. Default: <code>3</code>.</p> </li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#returns_2","title":"Returns","text":"<ul> <li>drifted_wave (<code>numpy.ndarray</code>):   The waveform with piecewise baseline drift.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#usage-example_2","title":"Usage Example","text":"<pre><code>drifted_wave = svg.apply_baseline_drift_piecewise(wave, max_drift=0.4, num_pieces=4)\n</code></pre>"},{"location":"functions/variations/9regional_baseline_drifts/#apply_baseline_drift_middle_peak","title":"<code>apply_baseline_drift_middle_peak</code>","text":"<p>Location: <code>variations/baseline_drift.py</code></p>"},{"location":"functions/variations/9regional_baseline_drifts/#description_3","title":"Description","text":"<p><code>apply_baseline_drift_middle_peak</code> applies a parabolic drift that peaks in the middle of the waveform. </p>"},{"location":"functions/variations/9regional_baseline_drifts/#notes_3","title":"Notes","text":"<ul> <li>Drift is zero at the start and end, with a peak at the center of the signal.  </li> <li>The peak can shift downward or upward, depending on the <code>direction</code>.  </li> <li>Works well for short-term drift simulations.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#parameters_3","title":"Parameters","text":"<ul> <li> <p>wave (<code>numpy.ndarray</code>):   The input signal.</p> </li> <li> <p>max_drift (<code>float</code>):   Maximum amplitude of the drift.</p> </li> <li> <p>direction (<code>str</code>, optional):  </p> </li> <li><code>'down'</code>: Peak drifts downward (negative shift).  </li> <li> <p><code>'up'</code>: Peak drifts upward (positive shift). Default: <code>'down'</code>.</p> </li> <li> <p>min_drift (<code>float</code>, optional):   Minimum drift value to ensure drift is non-zero. Default: <code>0</code>.</p> </li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#returns_3","title":"Returns","text":"<ul> <li>drifted_wave (<code>numpy.ndarray</code>):   The waveform with a middle-peak baseline drift.</li> </ul>"},{"location":"functions/variations/9regional_baseline_drifts/#usage-example_3","title":"Usage Example","text":"<pre><code>drifted_wave = svg.apply_baseline_drift_middle_peak(wave, max_drift=0.3, direction='up')\n</code></pre>"}]}